
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model GameSession
 * 
 */
export type GameSession = $Result.DefaultSelection<Prisma.$GameSessionPayload>
/**
 * Model SessionParticipant
 * 
 */
export type SessionParticipant = $Result.DefaultSelection<Prisma.$SessionParticipantPayload>
/**
 * Model SessionChat
 * 
 */
export type SessionChat = $Result.DefaultSelection<Prisma.$SessionChatPayload>
/**
 * Model UserGameLibrary
 * 
 */
export type UserGameLibrary = $Result.DefaultSelection<Prisma.$UserGameLibraryPayload>
/**
 * Model SessionHistory
 * 
 */
export type SessionHistory = $Result.DefaultSelection<Prisma.$SessionHistoryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SessionStatus: {
  STARTING: 'STARTING',
  ACTIVE: 'ACTIVE',
  ENDING: 'ENDING',
  ENDED: 'ENDED',
  ERROR: 'ERROR'
};

export type SessionStatus = (typeof SessionStatus)[keyof typeof SessionStatus]


export const SessionType: {
  SINGLE: 'SINGLE',
  MULTIPLAYER: 'MULTIPLAYER',
  SPECTATE: 'SPECTATE'
};

export type SessionType = (typeof SessionType)[keyof typeof SessionType]


export const VideoQuality: {
  Q720P: 'Q720P',
  Q1080P: 'Q1080P',
  Q1440P: 'Q1440P'
};

export type VideoQuality = (typeof VideoQuality)[keyof typeof VideoQuality]


export const ParticipantRole: {
  PLAYER: 'PLAYER',
  SPECTATOR: 'SPECTATOR',
  MODERATOR: 'MODERATOR'
};

export type ParticipantRole = (typeof ParticipantRole)[keyof typeof ParticipantRole]


export const MessageType: {
  CHAT: 'CHAT',
  SYSTEM: 'SYSTEM',
  GAME_EVENT: 'GAME_EVENT'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const GameStatus: {
  NOT_PLAYED: 'NOT_PLAYED',
  PLAYING: 'PLAYING',
  COMPLETED: 'COMPLETED',
  FAVORITE: 'FAVORITE'
};

export type GameStatus = (typeof GameStatus)[keyof typeof GameStatus]

}

export type SessionStatus = $Enums.SessionStatus

export const SessionStatus: typeof $Enums.SessionStatus

export type SessionType = $Enums.SessionType

export const SessionType: typeof $Enums.SessionType

export type VideoQuality = $Enums.VideoQuality

export const VideoQuality: typeof $Enums.VideoQuality

export type ParticipantRole = $Enums.ParticipantRole

export const ParticipantRole: typeof $Enums.ParticipantRole

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type GameStatus = $Enums.GameStatus

export const GameStatus: typeof $Enums.GameStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UserProfiles
 * const userProfiles = await prisma.userProfile.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UserProfiles
   * const userProfiles = await prisma.userProfile.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs>;

  /**
   * `prisma.gameSession`: Exposes CRUD operations for the **GameSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameSessions
    * const gameSessions = await prisma.gameSession.findMany()
    * ```
    */
  get gameSession(): Prisma.GameSessionDelegate<ExtArgs>;

  /**
   * `prisma.sessionParticipant`: Exposes CRUD operations for the **SessionParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionParticipants
    * const sessionParticipants = await prisma.sessionParticipant.findMany()
    * ```
    */
  get sessionParticipant(): Prisma.SessionParticipantDelegate<ExtArgs>;

  /**
   * `prisma.sessionChat`: Exposes CRUD operations for the **SessionChat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionChats
    * const sessionChats = await prisma.sessionChat.findMany()
    * ```
    */
  get sessionChat(): Prisma.SessionChatDelegate<ExtArgs>;

  /**
   * `prisma.userGameLibrary`: Exposes CRUD operations for the **UserGameLibrary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGameLibraries
    * const userGameLibraries = await prisma.userGameLibrary.findMany()
    * ```
    */
  get userGameLibrary(): Prisma.UserGameLibraryDelegate<ExtArgs>;

  /**
   * `prisma.sessionHistory`: Exposes CRUD operations for the **SessionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionHistories
    * const sessionHistories = await prisma.sessionHistory.findMany()
    * ```
    */
  get sessionHistory(): Prisma.SessionHistoryDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UserProfile: 'UserProfile',
    Game: 'Game',
    GameSession: 'GameSession',
    SessionParticipant: 'SessionParticipant',
    SessionChat: 'SessionChat',
    UserGameLibrary: 'UserGameLibrary',
    SessionHistory: 'SessionHistory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "userProfile" | "game" | "gameSession" | "sessionParticipant" | "sessionChat" | "userGameLibrary" | "sessionHistory"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      GameSession: {
        payload: Prisma.$GameSessionPayload<ExtArgs>
        fields: Prisma.GameSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          findFirst: {
            args: Prisma.GameSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          findMany: {
            args: Prisma.GameSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>[]
          }
          create: {
            args: Prisma.GameSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          createMany: {
            args: Prisma.GameSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>[]
          }
          delete: {
            args: Prisma.GameSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          update: {
            args: Prisma.GameSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          deleteMany: {
            args: Prisma.GameSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameSessionPayload>
          }
          aggregate: {
            args: Prisma.GameSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameSession>
          }
          groupBy: {
            args: Prisma.GameSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameSessionCountArgs<ExtArgs>
            result: $Utils.Optional<GameSessionCountAggregateOutputType> | number
          }
        }
      }
      SessionParticipant: {
        payload: Prisma.$SessionParticipantPayload<ExtArgs>
        fields: Prisma.SessionParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipantPayload>
          }
          findFirst: {
            args: Prisma.SessionParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipantPayload>
          }
          findMany: {
            args: Prisma.SessionParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipantPayload>[]
          }
          create: {
            args: Prisma.SessionParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipantPayload>
          }
          createMany: {
            args: Prisma.SessionParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipantPayload>[]
          }
          delete: {
            args: Prisma.SessionParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipantPayload>
          }
          update: {
            args: Prisma.SessionParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipantPayload>
          }
          deleteMany: {
            args: Prisma.SessionParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionParticipantPayload>
          }
          aggregate: {
            args: Prisma.SessionParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionParticipant>
          }
          groupBy: {
            args: Prisma.SessionParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<SessionParticipantCountAggregateOutputType> | number
          }
        }
      }
      SessionChat: {
        payload: Prisma.$SessionChatPayload<ExtArgs>
        fields: Prisma.SessionChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionChatPayload>
          }
          findFirst: {
            args: Prisma.SessionChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionChatPayload>
          }
          findMany: {
            args: Prisma.SessionChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionChatPayload>[]
          }
          create: {
            args: Prisma.SessionChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionChatPayload>
          }
          createMany: {
            args: Prisma.SessionChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionChatPayload>[]
          }
          delete: {
            args: Prisma.SessionChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionChatPayload>
          }
          update: {
            args: Prisma.SessionChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionChatPayload>
          }
          deleteMany: {
            args: Prisma.SessionChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionChatPayload>
          }
          aggregate: {
            args: Prisma.SessionChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionChat>
          }
          groupBy: {
            args: Prisma.SessionChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionChatCountArgs<ExtArgs>
            result: $Utils.Optional<SessionChatCountAggregateOutputType> | number
          }
        }
      }
      UserGameLibrary: {
        payload: Prisma.$UserGameLibraryPayload<ExtArgs>
        fields: Prisma.UserGameLibraryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserGameLibraryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGameLibraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserGameLibraryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGameLibraryPayload>
          }
          findFirst: {
            args: Prisma.UserGameLibraryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGameLibraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserGameLibraryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGameLibraryPayload>
          }
          findMany: {
            args: Prisma.UserGameLibraryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGameLibraryPayload>[]
          }
          create: {
            args: Prisma.UserGameLibraryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGameLibraryPayload>
          }
          createMany: {
            args: Prisma.UserGameLibraryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserGameLibraryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGameLibraryPayload>[]
          }
          delete: {
            args: Prisma.UserGameLibraryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGameLibraryPayload>
          }
          update: {
            args: Prisma.UserGameLibraryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGameLibraryPayload>
          }
          deleteMany: {
            args: Prisma.UserGameLibraryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserGameLibraryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserGameLibraryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGameLibraryPayload>
          }
          aggregate: {
            args: Prisma.UserGameLibraryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserGameLibrary>
          }
          groupBy: {
            args: Prisma.UserGameLibraryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGameLibraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserGameLibraryCountArgs<ExtArgs>
            result: $Utils.Optional<UserGameLibraryCountAggregateOutputType> | number
          }
        }
      }
      SessionHistory: {
        payload: Prisma.$SessionHistoryPayload<ExtArgs>
        fields: Prisma.SessionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>
          }
          findFirst: {
            args: Prisma.SessionHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>
          }
          findMany: {
            args: Prisma.SessionHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>[]
          }
          create: {
            args: Prisma.SessionHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>
          }
          createMany: {
            args: Prisma.SessionHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>[]
          }
          delete: {
            args: Prisma.SessionHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>
          }
          update: {
            args: Prisma.SessionHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SessionHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>
          }
          aggregate: {
            args: Prisma.SessionHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionHistory>
          }
          groupBy: {
            args: Prisma.SessionHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SessionHistoryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserProfileCountOutputType
   */

  export type UserProfileCountOutputType = {
    createdSessions: number
    library: number
    participations: number
    chatMessages: number
    sessionHistory: number
  }

  export type UserProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdSessions?: boolean | UserProfileCountOutputTypeCountCreatedSessionsArgs
    library?: boolean | UserProfileCountOutputTypeCountLibraryArgs
    participations?: boolean | UserProfileCountOutputTypeCountParticipationsArgs
    chatMessages?: boolean | UserProfileCountOutputTypeCountChatMessagesArgs
    sessionHistory?: boolean | UserProfileCountOutputTypeCountSessionHistoryArgs
  }

  // Custom InputTypes
  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileCountOutputType
     */
    select?: UserProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountCreatedSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountLibraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGameLibraryWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionParticipantWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountChatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionChatWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountSessionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionHistoryWhereInput
  }


  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    sessions: number
    libraryEntries: number
    sessionHistory: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | GameCountOutputTypeCountSessionsArgs
    libraryEntries?: boolean | GameCountOutputTypeCountLibraryEntriesArgs
    sessionHistory?: boolean | GameCountOutputTypeCountSessionHistoryArgs
  }

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountLibraryEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGameLibraryWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountSessionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionHistoryWhereInput
  }


  /**
   * Count Type GameSessionCountOutputType
   */

  export type GameSessionCountOutputType = {
    participants: number
    chatMessages: number
    history: number
  }

  export type GameSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | GameSessionCountOutputTypeCountParticipantsArgs
    chatMessages?: boolean | GameSessionCountOutputTypeCountChatMessagesArgs
    history?: boolean | GameSessionCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * GameSessionCountOutputType without action
   */
  export type GameSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSessionCountOutputType
     */
    select?: GameSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameSessionCountOutputType without action
   */
  export type GameSessionCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionParticipantWhereInput
  }

  /**
   * GameSessionCountOutputType without action
   */
  export type GameSessionCountOutputTypeCountChatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionChatWhereInput
  }

  /**
   * GameSessionCountOutputType without action
   */
  export type GameSessionCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionHistoryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    platiumUserId: string | null
    username: string | null
    displayName: string | null
    avatarUrl: string | null
    preferredEmulator: string | null
    isOnline: boolean | null
    lastSeenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    platiumUserId: string | null
    username: string | null
    displayName: string | null
    avatarUrl: string | null
    preferredEmulator: string | null
    isOnline: boolean | null
    lastSeenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    platiumUserId: number
    username: number
    displayName: number
    avatarUrl: number
    preferredEmulator: number
    isOnline: number
    lastSeenAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProfileMinAggregateInputType = {
    id?: true
    platiumUserId?: true
    username?: true
    displayName?: true
    avatarUrl?: true
    preferredEmulator?: true
    isOnline?: true
    lastSeenAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    platiumUserId?: true
    username?: true
    displayName?: true
    avatarUrl?: true
    preferredEmulator?: true
    isOnline?: true
    lastSeenAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    platiumUserId?: true
    username?: true
    displayName?: true
    avatarUrl?: true
    preferredEmulator?: true
    isOnline?: true
    lastSeenAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    platiumUserId: string
    username: string
    displayName: string | null
    avatarUrl: string | null
    preferredEmulator: string | null
    isOnline: boolean
    lastSeenAt: Date
    createdAt: Date
    updatedAt: Date
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platiumUserId?: boolean
    username?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    preferredEmulator?: boolean
    isOnline?: boolean
    lastSeenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdSessions?: boolean | UserProfile$createdSessionsArgs<ExtArgs>
    library?: boolean | UserProfile$libraryArgs<ExtArgs>
    participations?: boolean | UserProfile$participationsArgs<ExtArgs>
    chatMessages?: boolean | UserProfile$chatMessagesArgs<ExtArgs>
    sessionHistory?: boolean | UserProfile$sessionHistoryArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platiumUserId?: boolean
    username?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    preferredEmulator?: boolean
    isOnline?: boolean
    lastSeenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    platiumUserId?: boolean
    username?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    preferredEmulator?: boolean
    isOnline?: boolean
    lastSeenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdSessions?: boolean | UserProfile$createdSessionsArgs<ExtArgs>
    library?: boolean | UserProfile$libraryArgs<ExtArgs>
    participations?: boolean | UserProfile$participationsArgs<ExtArgs>
    chatMessages?: boolean | UserProfile$chatMessagesArgs<ExtArgs>
    sessionHistory?: boolean | UserProfile$sessionHistoryArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      createdSessions: Prisma.$GameSessionPayload<ExtArgs>[]
      library: Prisma.$UserGameLibraryPayload<ExtArgs>[]
      participations: Prisma.$SessionParticipantPayload<ExtArgs>[]
      chatMessages: Prisma.$SessionChatPayload<ExtArgs>[]
      sessionHistory: Prisma.$SessionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platiumUserId: string
      username: string
      displayName: string | null
      avatarUrl: string | null
      preferredEmulator: string | null
      isOnline: boolean
      lastSeenAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdSessions<T extends UserProfile$createdSessionsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$createdSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany"> | Null>
    library<T extends UserProfile$libraryArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$libraryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGameLibraryPayload<ExtArgs>, T, "findMany"> | Null>
    participations<T extends UserProfile$participationsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    chatMessages<T extends UserProfile$chatMessagesArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$chatMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionChatPayload<ExtArgs>, T, "findMany"> | Null>
    sessionHistory<T extends UserProfile$sessionHistoryArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$sessionHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */ 
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly platiumUserId: FieldRef<"UserProfile", 'String'>
    readonly username: FieldRef<"UserProfile", 'String'>
    readonly displayName: FieldRef<"UserProfile", 'String'>
    readonly avatarUrl: FieldRef<"UserProfile", 'String'>
    readonly preferredEmulator: FieldRef<"UserProfile", 'String'>
    readonly isOnline: FieldRef<"UserProfile", 'Boolean'>
    readonly lastSeenAt: FieldRef<"UserProfile", 'DateTime'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
  }

  /**
   * UserProfile.createdSessions
   */
  export type UserProfile$createdSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    cursor?: GameSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * UserProfile.library
   */
  export type UserProfile$libraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGameLibrary
     */
    select?: UserGameLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGameLibraryInclude<ExtArgs> | null
    where?: UserGameLibraryWhereInput
    orderBy?: UserGameLibraryOrderByWithRelationInput | UserGameLibraryOrderByWithRelationInput[]
    cursor?: UserGameLibraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGameLibraryScalarFieldEnum | UserGameLibraryScalarFieldEnum[]
  }

  /**
   * UserProfile.participations
   */
  export type UserProfile$participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipant
     */
    select?: SessionParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipantInclude<ExtArgs> | null
    where?: SessionParticipantWhereInput
    orderBy?: SessionParticipantOrderByWithRelationInput | SessionParticipantOrderByWithRelationInput[]
    cursor?: SessionParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionParticipantScalarFieldEnum | SessionParticipantScalarFieldEnum[]
  }

  /**
   * UserProfile.chatMessages
   */
  export type UserProfile$chatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionChat
     */
    select?: SessionChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionChatInclude<ExtArgs> | null
    where?: SessionChatWhereInput
    orderBy?: SessionChatOrderByWithRelationInput | SessionChatOrderByWithRelationInput[]
    cursor?: SessionChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionChatScalarFieldEnum | SessionChatScalarFieldEnum[]
  }

  /**
   * UserProfile.sessionHistory
   */
  export type UserProfile$sessionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    where?: SessionHistoryWhereInput
    orderBy?: SessionHistoryOrderByWithRelationInput | SessionHistoryOrderByWithRelationInput[]
    cursor?: SessionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionHistoryScalarFieldEnum | SessionHistoryScalarFieldEnum[]
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    year: number | null
    playerCount: number | null
    rating: Decimal | null
    playCount: number | null
  }

  export type GameSumAggregateOutputType = {
    year: number | null
    playerCount: number | null
    rating: Decimal | null
    playCount: number | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    system: string | null
    year: number | null
    genre: string | null
    playerCount: number | null
    romPath: string | null
    emulator: string | null
    emulatorCore: string | null
    coverArtUrl: string | null
    description: string | null
    rating: Decimal | null
    playCount: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    system: string | null
    year: number | null
    genre: string | null
    playerCount: number | null
    romPath: string | null
    emulator: string | null
    emulatorCore: string | null
    coverArtUrl: string | null
    description: string | null
    rating: Decimal | null
    playCount: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    system: number
    year: number
    genre: number
    playerCount: number
    romPath: number
    emulator: number
    emulatorCore: number
    coverArtUrl: number
    screenshotUrls: number
    description: number
    rating: number
    playCount: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    year?: true
    playerCount?: true
    rating?: true
    playCount?: true
  }

  export type GameSumAggregateInputType = {
    year?: true
    playerCount?: true
    rating?: true
    playCount?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    system?: true
    year?: true
    genre?: true
    playerCount?: true
    romPath?: true
    emulator?: true
    emulatorCore?: true
    coverArtUrl?: true
    description?: true
    rating?: true
    playCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    system?: true
    year?: true
    genre?: true
    playerCount?: true
    romPath?: true
    emulator?: true
    emulatorCore?: true
    coverArtUrl?: true
    description?: true
    rating?: true
    playCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    system?: true
    year?: true
    genre?: true
    playerCount?: true
    romPath?: true
    emulator?: true
    emulatorCore?: true
    coverArtUrl?: true
    screenshotUrls?: true
    description?: true
    rating?: true
    playCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    title: string
    slug: string
    system: string
    year: number | null
    genre: string | null
    playerCount: number
    romPath: string | null
    emulator: string
    emulatorCore: string | null
    coverArtUrl: string | null
    screenshotUrls: string[]
    description: string | null
    rating: Decimal | null
    playCount: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    system?: boolean
    year?: boolean
    genre?: boolean
    playerCount?: boolean
    romPath?: boolean
    emulator?: boolean
    emulatorCore?: boolean
    coverArtUrl?: boolean
    screenshotUrls?: boolean
    description?: boolean
    rating?: boolean
    playCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | Game$sessionsArgs<ExtArgs>
    libraryEntries?: boolean | Game$libraryEntriesArgs<ExtArgs>
    sessionHistory?: boolean | Game$sessionHistoryArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    system?: boolean
    year?: boolean
    genre?: boolean
    playerCount?: boolean
    romPath?: boolean
    emulator?: boolean
    emulatorCore?: boolean
    coverArtUrl?: boolean
    screenshotUrls?: boolean
    description?: boolean
    rating?: boolean
    playCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    system?: boolean
    year?: boolean
    genre?: boolean
    playerCount?: boolean
    romPath?: boolean
    emulator?: boolean
    emulatorCore?: boolean
    coverArtUrl?: boolean
    screenshotUrls?: boolean
    description?: boolean
    rating?: boolean
    playCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | Game$sessionsArgs<ExtArgs>
    libraryEntries?: boolean | Game$libraryEntriesArgs<ExtArgs>
    sessionHistory?: boolean | Game$sessionHistoryArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      sessions: Prisma.$GameSessionPayload<ExtArgs>[]
      libraryEntries: Prisma.$UserGameLibraryPayload<ExtArgs>[]
      sessionHistory: Prisma.$SessionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      system: string
      year: number | null
      genre: string | null
      playerCount: number
      romPath: string | null
      emulator: string
      emulatorCore: string | null
      coverArtUrl: string | null
      screenshotUrls: string[]
      description: string | null
      rating: Prisma.Decimal | null
      playCount: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends Game$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Game$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany"> | Null>
    libraryEntries<T extends Game$libraryEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Game$libraryEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGameLibraryPayload<ExtArgs>, T, "findMany"> | Null>
    sessionHistory<T extends Game$sessionHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Game$sessionHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */ 
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'String'>
    readonly title: FieldRef<"Game", 'String'>
    readonly slug: FieldRef<"Game", 'String'>
    readonly system: FieldRef<"Game", 'String'>
    readonly year: FieldRef<"Game", 'Int'>
    readonly genre: FieldRef<"Game", 'String'>
    readonly playerCount: FieldRef<"Game", 'Int'>
    readonly romPath: FieldRef<"Game", 'String'>
    readonly emulator: FieldRef<"Game", 'String'>
    readonly emulatorCore: FieldRef<"Game", 'String'>
    readonly coverArtUrl: FieldRef<"Game", 'String'>
    readonly screenshotUrls: FieldRef<"Game", 'String[]'>
    readonly description: FieldRef<"Game", 'String'>
    readonly rating: FieldRef<"Game", 'Decimal'>
    readonly playCount: FieldRef<"Game", 'Int'>
    readonly isActive: FieldRef<"Game", 'Boolean'>
    readonly createdAt: FieldRef<"Game", 'DateTime'>
    readonly updatedAt: FieldRef<"Game", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
  }

  /**
   * Game.sessions
   */
  export type Game$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    cursor?: GameSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * Game.libraryEntries
   */
  export type Game$libraryEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGameLibrary
     */
    select?: UserGameLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGameLibraryInclude<ExtArgs> | null
    where?: UserGameLibraryWhereInput
    orderBy?: UserGameLibraryOrderByWithRelationInput | UserGameLibraryOrderByWithRelationInput[]
    cursor?: UserGameLibraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGameLibraryScalarFieldEnum | UserGameLibraryScalarFieldEnum[]
  }

  /**
   * Game.sessionHistory
   */
  export type Game$sessionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    where?: SessionHistoryWhereInput
    orderBy?: SessionHistoryOrderByWithRelationInput | SessionHistoryOrderByWithRelationInput[]
    cursor?: SessionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionHistoryScalarFieldEnum | SessionHistoryScalarFieldEnum[]
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model GameSession
   */

  export type AggregateGameSession = {
    _count: GameSessionCountAggregateOutputType | null
    _avg: GameSessionAvgAggregateOutputType | null
    _sum: GameSessionSumAggregateOutputType | null
    _min: GameSessionMinAggregateOutputType | null
    _max: GameSessionMaxAggregateOutputType | null
  }

  export type GameSessionAvgAggregateOutputType = {
    maxPlayers: number | null
    currentPlayers: number | null
    spectatorCount: number | null
    containerPort: number | null
    fps: number | null
    durationMinutes: number | null
  }

  export type GameSessionSumAggregateOutputType = {
    maxPlayers: number | null
    currentPlayers: number | null
    spectatorCount: number | null
    containerPort: number | null
    fps: number | null
    durationMinutes: number | null
  }

  export type GameSessionMinAggregateOutputType = {
    id: string | null
    gameId: string | null
    createdBy: string | null
    sessionCode: string | null
    status: $Enums.SessionStatus | null
    sessionType: $Enums.SessionType | null
    isPrivate: boolean | null
    maxPlayers: number | null
    currentPlayers: number | null
    spectatorCount: number | null
    containerId: string | null
    containerIp: string | null
    containerPort: number | null
    videoQuality: $Enums.VideoQuality | null
    fps: number | null
    startedAt: Date | null
    endedAt: Date | null
    lastActivityAt: Date | null
    durationMinutes: number | null
  }

  export type GameSessionMaxAggregateOutputType = {
    id: string | null
    gameId: string | null
    createdBy: string | null
    sessionCode: string | null
    status: $Enums.SessionStatus | null
    sessionType: $Enums.SessionType | null
    isPrivate: boolean | null
    maxPlayers: number | null
    currentPlayers: number | null
    spectatorCount: number | null
    containerId: string | null
    containerIp: string | null
    containerPort: number | null
    videoQuality: $Enums.VideoQuality | null
    fps: number | null
    startedAt: Date | null
    endedAt: Date | null
    lastActivityAt: Date | null
    durationMinutes: number | null
  }

  export type GameSessionCountAggregateOutputType = {
    id: number
    gameId: number
    createdBy: number
    sessionCode: number
    status: number
    sessionType: number
    isPrivate: number
    maxPlayers: number
    currentPlayers: number
    spectatorCount: number
    containerId: number
    containerIp: number
    containerPort: number
    videoQuality: number
    fps: number
    startedAt: number
    endedAt: number
    lastActivityAt: number
    durationMinutes: number
    _all: number
  }


  export type GameSessionAvgAggregateInputType = {
    maxPlayers?: true
    currentPlayers?: true
    spectatorCount?: true
    containerPort?: true
    fps?: true
    durationMinutes?: true
  }

  export type GameSessionSumAggregateInputType = {
    maxPlayers?: true
    currentPlayers?: true
    spectatorCount?: true
    containerPort?: true
    fps?: true
    durationMinutes?: true
  }

  export type GameSessionMinAggregateInputType = {
    id?: true
    gameId?: true
    createdBy?: true
    sessionCode?: true
    status?: true
    sessionType?: true
    isPrivate?: true
    maxPlayers?: true
    currentPlayers?: true
    spectatorCount?: true
    containerId?: true
    containerIp?: true
    containerPort?: true
    videoQuality?: true
    fps?: true
    startedAt?: true
    endedAt?: true
    lastActivityAt?: true
    durationMinutes?: true
  }

  export type GameSessionMaxAggregateInputType = {
    id?: true
    gameId?: true
    createdBy?: true
    sessionCode?: true
    status?: true
    sessionType?: true
    isPrivate?: true
    maxPlayers?: true
    currentPlayers?: true
    spectatorCount?: true
    containerId?: true
    containerIp?: true
    containerPort?: true
    videoQuality?: true
    fps?: true
    startedAt?: true
    endedAt?: true
    lastActivityAt?: true
    durationMinutes?: true
  }

  export type GameSessionCountAggregateInputType = {
    id?: true
    gameId?: true
    createdBy?: true
    sessionCode?: true
    status?: true
    sessionType?: true
    isPrivate?: true
    maxPlayers?: true
    currentPlayers?: true
    spectatorCount?: true
    containerId?: true
    containerIp?: true
    containerPort?: true
    videoQuality?: true
    fps?: true
    startedAt?: true
    endedAt?: true
    lastActivityAt?: true
    durationMinutes?: true
    _all?: true
  }

  export type GameSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameSession to aggregate.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameSessions
    **/
    _count?: true | GameSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameSessionMaxAggregateInputType
  }

  export type GetGameSessionAggregateType<T extends GameSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateGameSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameSession[P]>
      : GetScalarType<T[P], AggregateGameSession[P]>
  }




  export type GameSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameSessionWhereInput
    orderBy?: GameSessionOrderByWithAggregationInput | GameSessionOrderByWithAggregationInput[]
    by: GameSessionScalarFieldEnum[] | GameSessionScalarFieldEnum
    having?: GameSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameSessionCountAggregateInputType | true
    _avg?: GameSessionAvgAggregateInputType
    _sum?: GameSessionSumAggregateInputType
    _min?: GameSessionMinAggregateInputType
    _max?: GameSessionMaxAggregateInputType
  }

  export type GameSessionGroupByOutputType = {
    id: string
    gameId: string
    createdBy: string
    sessionCode: string | null
    status: $Enums.SessionStatus
    sessionType: $Enums.SessionType
    isPrivate: boolean
    maxPlayers: number
    currentPlayers: number
    spectatorCount: number
    containerId: string | null
    containerIp: string | null
    containerPort: number | null
    videoQuality: $Enums.VideoQuality
    fps: number
    startedAt: Date
    endedAt: Date | null
    lastActivityAt: Date
    durationMinutes: number | null
    _count: GameSessionCountAggregateOutputType | null
    _avg: GameSessionAvgAggregateOutputType | null
    _sum: GameSessionSumAggregateOutputType | null
    _min: GameSessionMinAggregateOutputType | null
    _max: GameSessionMaxAggregateOutputType | null
  }

  type GetGameSessionGroupByPayload<T extends GameSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameSessionGroupByOutputType[P]>
            : GetScalarType<T[P], GameSessionGroupByOutputType[P]>
        }
      >
    >


  export type GameSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    createdBy?: boolean
    sessionCode?: boolean
    status?: boolean
    sessionType?: boolean
    isPrivate?: boolean
    maxPlayers?: boolean
    currentPlayers?: boolean
    spectatorCount?: boolean
    containerId?: boolean
    containerIp?: boolean
    containerPort?: boolean
    videoQuality?: boolean
    fps?: boolean
    startedAt?: boolean
    endedAt?: boolean
    lastActivityAt?: boolean
    durationMinutes?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    creator?: boolean | UserProfileDefaultArgs<ExtArgs>
    participants?: boolean | GameSession$participantsArgs<ExtArgs>
    chatMessages?: boolean | GameSession$chatMessagesArgs<ExtArgs>
    history?: boolean | GameSession$historyArgs<ExtArgs>
    _count?: boolean | GameSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameSession"]>

  export type GameSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    createdBy?: boolean
    sessionCode?: boolean
    status?: boolean
    sessionType?: boolean
    isPrivate?: boolean
    maxPlayers?: boolean
    currentPlayers?: boolean
    spectatorCount?: boolean
    containerId?: boolean
    containerIp?: boolean
    containerPort?: boolean
    videoQuality?: boolean
    fps?: boolean
    startedAt?: boolean
    endedAt?: boolean
    lastActivityAt?: boolean
    durationMinutes?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    creator?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameSession"]>

  export type GameSessionSelectScalar = {
    id?: boolean
    gameId?: boolean
    createdBy?: boolean
    sessionCode?: boolean
    status?: boolean
    sessionType?: boolean
    isPrivate?: boolean
    maxPlayers?: boolean
    currentPlayers?: boolean
    spectatorCount?: boolean
    containerId?: boolean
    containerIp?: boolean
    containerPort?: boolean
    videoQuality?: boolean
    fps?: boolean
    startedAt?: boolean
    endedAt?: boolean
    lastActivityAt?: boolean
    durationMinutes?: boolean
  }

  export type GameSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    creator?: boolean | UserProfileDefaultArgs<ExtArgs>
    participants?: boolean | GameSession$participantsArgs<ExtArgs>
    chatMessages?: boolean | GameSession$chatMessagesArgs<ExtArgs>
    history?: boolean | GameSession$historyArgs<ExtArgs>
    _count?: boolean | GameSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    creator?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $GameSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameSession"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      creator: Prisma.$UserProfilePayload<ExtArgs>
      participants: Prisma.$SessionParticipantPayload<ExtArgs>[]
      chatMessages: Prisma.$SessionChatPayload<ExtArgs>[]
      history: Prisma.$SessionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameId: string
      createdBy: string
      sessionCode: string | null
      status: $Enums.SessionStatus
      sessionType: $Enums.SessionType
      isPrivate: boolean
      maxPlayers: number
      currentPlayers: number
      spectatorCount: number
      containerId: string | null
      containerIp: string | null
      containerPort: number | null
      videoQuality: $Enums.VideoQuality
      fps: number
      startedAt: Date
      endedAt: Date | null
      lastActivityAt: Date
      durationMinutes: number | null
    }, ExtArgs["result"]["gameSession"]>
    composites: {}
  }

  type GameSessionGetPayload<S extends boolean | null | undefined | GameSessionDefaultArgs> = $Result.GetResult<Prisma.$GameSessionPayload, S>

  type GameSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameSessionCountAggregateInputType | true
    }

  export interface GameSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameSession'], meta: { name: 'GameSession' } }
    /**
     * Find zero or one GameSession that matches the filter.
     * @param {GameSessionFindUniqueArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameSessionFindUniqueArgs>(args: SelectSubset<T, GameSessionFindUniqueArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GameSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GameSessionFindUniqueOrThrowArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, GameSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GameSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindFirstArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameSessionFindFirstArgs>(args?: SelectSubset<T, GameSessionFindFirstArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GameSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindFirstOrThrowArgs} args - Arguments to find a GameSession
     * @example
     * // Get one GameSession
     * const gameSession = await prisma.gameSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, GameSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GameSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameSessions
     * const gameSessions = await prisma.gameSession.findMany()
     * 
     * // Get first 10 GameSessions
     * const gameSessions = await prisma.gameSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameSessionWithIdOnly = await prisma.gameSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameSessionFindManyArgs>(args?: SelectSubset<T, GameSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GameSession.
     * @param {GameSessionCreateArgs} args - Arguments to create a GameSession.
     * @example
     * // Create one GameSession
     * const GameSession = await prisma.gameSession.create({
     *   data: {
     *     // ... data to create a GameSession
     *   }
     * })
     * 
     */
    create<T extends GameSessionCreateArgs>(args: SelectSubset<T, GameSessionCreateArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GameSessions.
     * @param {GameSessionCreateManyArgs} args - Arguments to create many GameSessions.
     * @example
     * // Create many GameSessions
     * const gameSession = await prisma.gameSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameSessionCreateManyArgs>(args?: SelectSubset<T, GameSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameSessions and returns the data saved in the database.
     * @param {GameSessionCreateManyAndReturnArgs} args - Arguments to create many GameSessions.
     * @example
     * // Create many GameSessions
     * const gameSession = await prisma.gameSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameSessions and only return the `id`
     * const gameSessionWithIdOnly = await prisma.gameSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, GameSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GameSession.
     * @param {GameSessionDeleteArgs} args - Arguments to delete one GameSession.
     * @example
     * // Delete one GameSession
     * const GameSession = await prisma.gameSession.delete({
     *   where: {
     *     // ... filter to delete one GameSession
     *   }
     * })
     * 
     */
    delete<T extends GameSessionDeleteArgs>(args: SelectSubset<T, GameSessionDeleteArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GameSession.
     * @param {GameSessionUpdateArgs} args - Arguments to update one GameSession.
     * @example
     * // Update one GameSession
     * const gameSession = await prisma.gameSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameSessionUpdateArgs>(args: SelectSubset<T, GameSessionUpdateArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GameSessions.
     * @param {GameSessionDeleteManyArgs} args - Arguments to filter GameSessions to delete.
     * @example
     * // Delete a few GameSessions
     * const { count } = await prisma.gameSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameSessionDeleteManyArgs>(args?: SelectSubset<T, GameSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameSessions
     * const gameSession = await prisma.gameSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameSessionUpdateManyArgs>(args: SelectSubset<T, GameSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameSession.
     * @param {GameSessionUpsertArgs} args - Arguments to update or create a GameSession.
     * @example
     * // Update or create a GameSession
     * const gameSession = await prisma.gameSession.upsert({
     *   create: {
     *     // ... data to create a GameSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameSession we want to update
     *   }
     * })
     */
    upsert<T extends GameSessionUpsertArgs>(args: SelectSubset<T, GameSessionUpsertArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GameSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionCountArgs} args - Arguments to filter GameSessions to count.
     * @example
     * // Count the number of GameSessions
     * const count = await prisma.gameSession.count({
     *   where: {
     *     // ... the filter for the GameSessions we want to count
     *   }
     * })
    **/
    count<T extends GameSessionCountArgs>(
      args?: Subset<T, GameSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameSessionAggregateArgs>(args: Subset<T, GameSessionAggregateArgs>): Prisma.PrismaPromise<GetGameSessionAggregateType<T>>

    /**
     * Group by GameSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameSessionGroupByArgs['orderBy'] }
        : { orderBy?: GameSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameSession model
   */
  readonly fields: GameSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    participants<T extends GameSession$participantsArgs<ExtArgs> = {}>(args?: Subset<T, GameSession$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    chatMessages<T extends GameSession$chatMessagesArgs<ExtArgs> = {}>(args?: Subset<T, GameSession$chatMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionChatPayload<ExtArgs>, T, "findMany"> | Null>
    history<T extends GameSession$historyArgs<ExtArgs> = {}>(args?: Subset<T, GameSession$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameSession model
   */ 
  interface GameSessionFieldRefs {
    readonly id: FieldRef<"GameSession", 'String'>
    readonly gameId: FieldRef<"GameSession", 'String'>
    readonly createdBy: FieldRef<"GameSession", 'String'>
    readonly sessionCode: FieldRef<"GameSession", 'String'>
    readonly status: FieldRef<"GameSession", 'SessionStatus'>
    readonly sessionType: FieldRef<"GameSession", 'SessionType'>
    readonly isPrivate: FieldRef<"GameSession", 'Boolean'>
    readonly maxPlayers: FieldRef<"GameSession", 'Int'>
    readonly currentPlayers: FieldRef<"GameSession", 'Int'>
    readonly spectatorCount: FieldRef<"GameSession", 'Int'>
    readonly containerId: FieldRef<"GameSession", 'String'>
    readonly containerIp: FieldRef<"GameSession", 'String'>
    readonly containerPort: FieldRef<"GameSession", 'Int'>
    readonly videoQuality: FieldRef<"GameSession", 'VideoQuality'>
    readonly fps: FieldRef<"GameSession", 'Int'>
    readonly startedAt: FieldRef<"GameSession", 'DateTime'>
    readonly endedAt: FieldRef<"GameSession", 'DateTime'>
    readonly lastActivityAt: FieldRef<"GameSession", 'DateTime'>
    readonly durationMinutes: FieldRef<"GameSession", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GameSession findUnique
   */
  export type GameSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession findUniqueOrThrow
   */
  export type GameSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession findFirst
   */
  export type GameSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameSessions.
     */
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession findFirstOrThrow
   */
  export type GameSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSession to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameSessions.
     */
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession findMany
   */
  export type GameSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter, which GameSessions to fetch.
     */
    where?: GameSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameSessions to fetch.
     */
    orderBy?: GameSessionOrderByWithRelationInput | GameSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameSessions.
     */
    cursor?: GameSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameSessions.
     */
    skip?: number
    distinct?: GameSessionScalarFieldEnum | GameSessionScalarFieldEnum[]
  }

  /**
   * GameSession create
   */
  export type GameSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a GameSession.
     */
    data: XOR<GameSessionCreateInput, GameSessionUncheckedCreateInput>
  }

  /**
   * GameSession createMany
   */
  export type GameSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameSessions.
     */
    data: GameSessionCreateManyInput | GameSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameSession createManyAndReturn
   */
  export type GameSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GameSessions.
     */
    data: GameSessionCreateManyInput | GameSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameSession update
   */
  export type GameSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a GameSession.
     */
    data: XOR<GameSessionUpdateInput, GameSessionUncheckedUpdateInput>
    /**
     * Choose, which GameSession to update.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession updateMany
   */
  export type GameSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameSessions.
     */
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyInput>
    /**
     * Filter which GameSessions to update
     */
    where?: GameSessionWhereInput
  }

  /**
   * GameSession upsert
   */
  export type GameSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the GameSession to update in case it exists.
     */
    where: GameSessionWhereUniqueInput
    /**
     * In case the GameSession found by the `where` argument doesn't exist, create a new GameSession with this data.
     */
    create: XOR<GameSessionCreateInput, GameSessionUncheckedCreateInput>
    /**
     * In case the GameSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameSessionUpdateInput, GameSessionUncheckedUpdateInput>
  }

  /**
   * GameSession delete
   */
  export type GameSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
    /**
     * Filter which GameSession to delete.
     */
    where: GameSessionWhereUniqueInput
  }

  /**
   * GameSession deleteMany
   */
  export type GameSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameSessions to delete
     */
    where?: GameSessionWhereInput
  }

  /**
   * GameSession.participants
   */
  export type GameSession$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipant
     */
    select?: SessionParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipantInclude<ExtArgs> | null
    where?: SessionParticipantWhereInput
    orderBy?: SessionParticipantOrderByWithRelationInput | SessionParticipantOrderByWithRelationInput[]
    cursor?: SessionParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionParticipantScalarFieldEnum | SessionParticipantScalarFieldEnum[]
  }

  /**
   * GameSession.chatMessages
   */
  export type GameSession$chatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionChat
     */
    select?: SessionChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionChatInclude<ExtArgs> | null
    where?: SessionChatWhereInput
    orderBy?: SessionChatOrderByWithRelationInput | SessionChatOrderByWithRelationInput[]
    cursor?: SessionChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionChatScalarFieldEnum | SessionChatScalarFieldEnum[]
  }

  /**
   * GameSession.history
   */
  export type GameSession$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    where?: SessionHistoryWhereInput
    orderBy?: SessionHistoryOrderByWithRelationInput | SessionHistoryOrderByWithRelationInput[]
    cursor?: SessionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionHistoryScalarFieldEnum | SessionHistoryScalarFieldEnum[]
  }

  /**
   * GameSession without action
   */
  export type GameSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameSession
     */
    select?: GameSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameSessionInclude<ExtArgs> | null
  }


  /**
   * Model SessionParticipant
   */

  export type AggregateSessionParticipant = {
    _count: SessionParticipantCountAggregateOutputType | null
    _avg: SessionParticipantAvgAggregateOutputType | null
    _sum: SessionParticipantSumAggregateOutputType | null
    _min: SessionParticipantMinAggregateOutputType | null
    _max: SessionParticipantMaxAggregateOutputType | null
  }

  export type SessionParticipantAvgAggregateOutputType = {
    totalDurationMinutes: number | null
  }

  export type SessionParticipantSumAggregateOutputType = {
    totalDurationMinutes: number | null
  }

  export type SessionParticipantMinAggregateOutputType = {
    sessionId: string | null
    userId: string | null
    role: $Enums.ParticipantRole | null
    isHost: boolean | null
    joinedAt: Date | null
    leftAt: Date | null
    totalDurationMinutes: number | null
  }

  export type SessionParticipantMaxAggregateOutputType = {
    sessionId: string | null
    userId: string | null
    role: $Enums.ParticipantRole | null
    isHost: boolean | null
    joinedAt: Date | null
    leftAt: Date | null
    totalDurationMinutes: number | null
  }

  export type SessionParticipantCountAggregateOutputType = {
    sessionId: number
    userId: number
    role: number
    isHost: number
    joinedAt: number
    leftAt: number
    totalDurationMinutes: number
    _all: number
  }


  export type SessionParticipantAvgAggregateInputType = {
    totalDurationMinutes?: true
  }

  export type SessionParticipantSumAggregateInputType = {
    totalDurationMinutes?: true
  }

  export type SessionParticipantMinAggregateInputType = {
    sessionId?: true
    userId?: true
    role?: true
    isHost?: true
    joinedAt?: true
    leftAt?: true
    totalDurationMinutes?: true
  }

  export type SessionParticipantMaxAggregateInputType = {
    sessionId?: true
    userId?: true
    role?: true
    isHost?: true
    joinedAt?: true
    leftAt?: true
    totalDurationMinutes?: true
  }

  export type SessionParticipantCountAggregateInputType = {
    sessionId?: true
    userId?: true
    role?: true
    isHost?: true
    joinedAt?: true
    leftAt?: true
    totalDurationMinutes?: true
    _all?: true
  }

  export type SessionParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionParticipant to aggregate.
     */
    where?: SessionParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionParticipants to fetch.
     */
    orderBy?: SessionParticipantOrderByWithRelationInput | SessionParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionParticipants
    **/
    _count?: true | SessionParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionParticipantMaxAggregateInputType
  }

  export type GetSessionParticipantAggregateType<T extends SessionParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionParticipant[P]>
      : GetScalarType<T[P], AggregateSessionParticipant[P]>
  }




  export type SessionParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionParticipantWhereInput
    orderBy?: SessionParticipantOrderByWithAggregationInput | SessionParticipantOrderByWithAggregationInput[]
    by: SessionParticipantScalarFieldEnum[] | SessionParticipantScalarFieldEnum
    having?: SessionParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionParticipantCountAggregateInputType | true
    _avg?: SessionParticipantAvgAggregateInputType
    _sum?: SessionParticipantSumAggregateInputType
    _min?: SessionParticipantMinAggregateInputType
    _max?: SessionParticipantMaxAggregateInputType
  }

  export type SessionParticipantGroupByOutputType = {
    sessionId: string
    userId: string
    role: $Enums.ParticipantRole
    isHost: boolean
    joinedAt: Date
    leftAt: Date | null
    totalDurationMinutes: number
    _count: SessionParticipantCountAggregateOutputType | null
    _avg: SessionParticipantAvgAggregateOutputType | null
    _sum: SessionParticipantSumAggregateOutputType | null
    _min: SessionParticipantMinAggregateOutputType | null
    _max: SessionParticipantMaxAggregateOutputType | null
  }

  type GetSessionParticipantGroupByPayload<T extends SessionParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], SessionParticipantGroupByOutputType[P]>
        }
      >
    >


  export type SessionParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    userId?: boolean
    role?: boolean
    isHost?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    totalDurationMinutes?: boolean
    session?: boolean | GameSessionDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionParticipant"]>

  export type SessionParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    userId?: boolean
    role?: boolean
    isHost?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    totalDurationMinutes?: boolean
    session?: boolean | GameSessionDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionParticipant"]>

  export type SessionParticipantSelectScalar = {
    sessionId?: boolean
    userId?: boolean
    role?: boolean
    isHost?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    totalDurationMinutes?: boolean
  }

  export type SessionParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | GameSessionDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type SessionParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | GameSessionDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $SessionParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionParticipant"
    objects: {
      session: Prisma.$GameSessionPayload<ExtArgs>
      user: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionId: string
      userId: string
      role: $Enums.ParticipantRole
      isHost: boolean
      joinedAt: Date
      leftAt: Date | null
      totalDurationMinutes: number
    }, ExtArgs["result"]["sessionParticipant"]>
    composites: {}
  }

  type SessionParticipantGetPayload<S extends boolean | null | undefined | SessionParticipantDefaultArgs> = $Result.GetResult<Prisma.$SessionParticipantPayload, S>

  type SessionParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionParticipantCountAggregateInputType | true
    }

  export interface SessionParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionParticipant'], meta: { name: 'SessionParticipant' } }
    /**
     * Find zero or one SessionParticipant that matches the filter.
     * @param {SessionParticipantFindUniqueArgs} args - Arguments to find a SessionParticipant
     * @example
     * // Get one SessionParticipant
     * const sessionParticipant = await prisma.sessionParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionParticipantFindUniqueArgs>(args: SelectSubset<T, SessionParticipantFindUniqueArgs<ExtArgs>>): Prisma__SessionParticipantClient<$Result.GetResult<Prisma.$SessionParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionParticipantFindUniqueOrThrowArgs} args - Arguments to find a SessionParticipant
     * @example
     * // Get one SessionParticipant
     * const sessionParticipant = await prisma.sessionParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionParticipantClient<$Result.GetResult<Prisma.$SessionParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipantFindFirstArgs} args - Arguments to find a SessionParticipant
     * @example
     * // Get one SessionParticipant
     * const sessionParticipant = await prisma.sessionParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionParticipantFindFirstArgs>(args?: SelectSubset<T, SessionParticipantFindFirstArgs<ExtArgs>>): Prisma__SessionParticipantClient<$Result.GetResult<Prisma.$SessionParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipantFindFirstOrThrowArgs} args - Arguments to find a SessionParticipant
     * @example
     * // Get one SessionParticipant
     * const sessionParticipant = await prisma.sessionParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionParticipantClient<$Result.GetResult<Prisma.$SessionParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionParticipants
     * const sessionParticipants = await prisma.sessionParticipant.findMany()
     * 
     * // Get first 10 SessionParticipants
     * const sessionParticipants = await prisma.sessionParticipant.findMany({ take: 10 })
     * 
     * // Only select the `sessionId`
     * const sessionParticipantWithSessionIdOnly = await prisma.sessionParticipant.findMany({ select: { sessionId: true } })
     * 
     */
    findMany<T extends SessionParticipantFindManyArgs>(args?: SelectSubset<T, SessionParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionParticipant.
     * @param {SessionParticipantCreateArgs} args - Arguments to create a SessionParticipant.
     * @example
     * // Create one SessionParticipant
     * const SessionParticipant = await prisma.sessionParticipant.create({
     *   data: {
     *     // ... data to create a SessionParticipant
     *   }
     * })
     * 
     */
    create<T extends SessionParticipantCreateArgs>(args: SelectSubset<T, SessionParticipantCreateArgs<ExtArgs>>): Prisma__SessionParticipantClient<$Result.GetResult<Prisma.$SessionParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionParticipants.
     * @param {SessionParticipantCreateManyArgs} args - Arguments to create many SessionParticipants.
     * @example
     * // Create many SessionParticipants
     * const sessionParticipant = await prisma.sessionParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionParticipantCreateManyArgs>(args?: SelectSubset<T, SessionParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionParticipants and returns the data saved in the database.
     * @param {SessionParticipantCreateManyAndReturnArgs} args - Arguments to create many SessionParticipants.
     * @example
     * // Create many SessionParticipants
     * const sessionParticipant = await prisma.sessionParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionParticipants and only return the `sessionId`
     * const sessionParticipantWithSessionIdOnly = await prisma.sessionParticipant.createManyAndReturn({ 
     *   select: { sessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionParticipant.
     * @param {SessionParticipantDeleteArgs} args - Arguments to delete one SessionParticipant.
     * @example
     * // Delete one SessionParticipant
     * const SessionParticipant = await prisma.sessionParticipant.delete({
     *   where: {
     *     // ... filter to delete one SessionParticipant
     *   }
     * })
     * 
     */
    delete<T extends SessionParticipantDeleteArgs>(args: SelectSubset<T, SessionParticipantDeleteArgs<ExtArgs>>): Prisma__SessionParticipantClient<$Result.GetResult<Prisma.$SessionParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionParticipant.
     * @param {SessionParticipantUpdateArgs} args - Arguments to update one SessionParticipant.
     * @example
     * // Update one SessionParticipant
     * const sessionParticipant = await prisma.sessionParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionParticipantUpdateArgs>(args: SelectSubset<T, SessionParticipantUpdateArgs<ExtArgs>>): Prisma__SessionParticipantClient<$Result.GetResult<Prisma.$SessionParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionParticipants.
     * @param {SessionParticipantDeleteManyArgs} args - Arguments to filter SessionParticipants to delete.
     * @example
     * // Delete a few SessionParticipants
     * const { count } = await prisma.sessionParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionParticipantDeleteManyArgs>(args?: SelectSubset<T, SessionParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionParticipants
     * const sessionParticipant = await prisma.sessionParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionParticipantUpdateManyArgs>(args: SelectSubset<T, SessionParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionParticipant.
     * @param {SessionParticipantUpsertArgs} args - Arguments to update or create a SessionParticipant.
     * @example
     * // Update or create a SessionParticipant
     * const sessionParticipant = await prisma.sessionParticipant.upsert({
     *   create: {
     *     // ... data to create a SessionParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionParticipant we want to update
     *   }
     * })
     */
    upsert<T extends SessionParticipantUpsertArgs>(args: SelectSubset<T, SessionParticipantUpsertArgs<ExtArgs>>): Prisma__SessionParticipantClient<$Result.GetResult<Prisma.$SessionParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipantCountArgs} args - Arguments to filter SessionParticipants to count.
     * @example
     * // Count the number of SessionParticipants
     * const count = await prisma.sessionParticipant.count({
     *   where: {
     *     // ... the filter for the SessionParticipants we want to count
     *   }
     * })
    **/
    count<T extends SessionParticipantCountArgs>(
      args?: Subset<T, SessionParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionParticipantAggregateArgs>(args: Subset<T, SessionParticipantAggregateArgs>): Prisma.PrismaPromise<GetSessionParticipantAggregateType<T>>

    /**
     * Group by SessionParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionParticipantGroupByArgs['orderBy'] }
        : { orderBy?: SessionParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionParticipant model
   */
  readonly fields: SessionParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends GameSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameSessionDefaultArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionParticipant model
   */ 
  interface SessionParticipantFieldRefs {
    readonly sessionId: FieldRef<"SessionParticipant", 'String'>
    readonly userId: FieldRef<"SessionParticipant", 'String'>
    readonly role: FieldRef<"SessionParticipant", 'ParticipantRole'>
    readonly isHost: FieldRef<"SessionParticipant", 'Boolean'>
    readonly joinedAt: FieldRef<"SessionParticipant", 'DateTime'>
    readonly leftAt: FieldRef<"SessionParticipant", 'DateTime'>
    readonly totalDurationMinutes: FieldRef<"SessionParticipant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SessionParticipant findUnique
   */
  export type SessionParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipant
     */
    select?: SessionParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipantInclude<ExtArgs> | null
    /**
     * Filter, which SessionParticipant to fetch.
     */
    where: SessionParticipantWhereUniqueInput
  }

  /**
   * SessionParticipant findUniqueOrThrow
   */
  export type SessionParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipant
     */
    select?: SessionParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipantInclude<ExtArgs> | null
    /**
     * Filter, which SessionParticipant to fetch.
     */
    where: SessionParticipantWhereUniqueInput
  }

  /**
   * SessionParticipant findFirst
   */
  export type SessionParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipant
     */
    select?: SessionParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipantInclude<ExtArgs> | null
    /**
     * Filter, which SessionParticipant to fetch.
     */
    where?: SessionParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionParticipants to fetch.
     */
    orderBy?: SessionParticipantOrderByWithRelationInput | SessionParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionParticipants.
     */
    cursor?: SessionParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionParticipants.
     */
    distinct?: SessionParticipantScalarFieldEnum | SessionParticipantScalarFieldEnum[]
  }

  /**
   * SessionParticipant findFirstOrThrow
   */
  export type SessionParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipant
     */
    select?: SessionParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipantInclude<ExtArgs> | null
    /**
     * Filter, which SessionParticipant to fetch.
     */
    where?: SessionParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionParticipants to fetch.
     */
    orderBy?: SessionParticipantOrderByWithRelationInput | SessionParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionParticipants.
     */
    cursor?: SessionParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionParticipants.
     */
    distinct?: SessionParticipantScalarFieldEnum | SessionParticipantScalarFieldEnum[]
  }

  /**
   * SessionParticipant findMany
   */
  export type SessionParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipant
     */
    select?: SessionParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipantInclude<ExtArgs> | null
    /**
     * Filter, which SessionParticipants to fetch.
     */
    where?: SessionParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionParticipants to fetch.
     */
    orderBy?: SessionParticipantOrderByWithRelationInput | SessionParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionParticipants.
     */
    cursor?: SessionParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionParticipants.
     */
    skip?: number
    distinct?: SessionParticipantScalarFieldEnum | SessionParticipantScalarFieldEnum[]
  }

  /**
   * SessionParticipant create
   */
  export type SessionParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipant
     */
    select?: SessionParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionParticipant.
     */
    data: XOR<SessionParticipantCreateInput, SessionParticipantUncheckedCreateInput>
  }

  /**
   * SessionParticipant createMany
   */
  export type SessionParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionParticipants.
     */
    data: SessionParticipantCreateManyInput | SessionParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionParticipant createManyAndReturn
   */
  export type SessionParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipant
     */
    select?: SessionParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionParticipants.
     */
    data: SessionParticipantCreateManyInput | SessionParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionParticipant update
   */
  export type SessionParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipant
     */
    select?: SessionParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionParticipant.
     */
    data: XOR<SessionParticipantUpdateInput, SessionParticipantUncheckedUpdateInput>
    /**
     * Choose, which SessionParticipant to update.
     */
    where: SessionParticipantWhereUniqueInput
  }

  /**
   * SessionParticipant updateMany
   */
  export type SessionParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionParticipants.
     */
    data: XOR<SessionParticipantUpdateManyMutationInput, SessionParticipantUncheckedUpdateManyInput>
    /**
     * Filter which SessionParticipants to update
     */
    where?: SessionParticipantWhereInput
  }

  /**
   * SessionParticipant upsert
   */
  export type SessionParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipant
     */
    select?: SessionParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionParticipant to update in case it exists.
     */
    where: SessionParticipantWhereUniqueInput
    /**
     * In case the SessionParticipant found by the `where` argument doesn't exist, create a new SessionParticipant with this data.
     */
    create: XOR<SessionParticipantCreateInput, SessionParticipantUncheckedCreateInput>
    /**
     * In case the SessionParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionParticipantUpdateInput, SessionParticipantUncheckedUpdateInput>
  }

  /**
   * SessionParticipant delete
   */
  export type SessionParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipant
     */
    select?: SessionParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipantInclude<ExtArgs> | null
    /**
     * Filter which SessionParticipant to delete.
     */
    where: SessionParticipantWhereUniqueInput
  }

  /**
   * SessionParticipant deleteMany
   */
  export type SessionParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionParticipants to delete
     */
    where?: SessionParticipantWhereInput
  }

  /**
   * SessionParticipant without action
   */
  export type SessionParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionParticipant
     */
    select?: SessionParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionParticipantInclude<ExtArgs> | null
  }


  /**
   * Model SessionChat
   */

  export type AggregateSessionChat = {
    _count: SessionChatCountAggregateOutputType | null
    _min: SessionChatMinAggregateOutputType | null
    _max: SessionChatMaxAggregateOutputType | null
  }

  export type SessionChatMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    message: string | null
    type: $Enums.MessageType | null
    createdAt: Date | null
  }

  export type SessionChatMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    message: string | null
    type: $Enums.MessageType | null
    createdAt: Date | null
  }

  export type SessionChatCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    message: number
    type: number
    createdAt: number
    _all: number
  }


  export type SessionChatMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    message?: true
    type?: true
    createdAt?: true
  }

  export type SessionChatMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    message?: true
    type?: true
    createdAt?: true
  }

  export type SessionChatCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    message?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type SessionChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionChat to aggregate.
     */
    where?: SessionChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionChats to fetch.
     */
    orderBy?: SessionChatOrderByWithRelationInput | SessionChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionChats
    **/
    _count?: true | SessionChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionChatMaxAggregateInputType
  }

  export type GetSessionChatAggregateType<T extends SessionChatAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionChat[P]>
      : GetScalarType<T[P], AggregateSessionChat[P]>
  }




  export type SessionChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionChatWhereInput
    orderBy?: SessionChatOrderByWithAggregationInput | SessionChatOrderByWithAggregationInput[]
    by: SessionChatScalarFieldEnum[] | SessionChatScalarFieldEnum
    having?: SessionChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionChatCountAggregateInputType | true
    _min?: SessionChatMinAggregateInputType
    _max?: SessionChatMaxAggregateInputType
  }

  export type SessionChatGroupByOutputType = {
    id: string
    sessionId: string
    userId: string
    message: string
    type: $Enums.MessageType
    createdAt: Date
    _count: SessionChatCountAggregateOutputType | null
    _min: SessionChatMinAggregateOutputType | null
    _max: SessionChatMaxAggregateOutputType | null
  }

  type GetSessionChatGroupByPayload<T extends SessionChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionChatGroupByOutputType[P]>
            : GetScalarType<T[P], SessionChatGroupByOutputType[P]>
        }
      >
    >


  export type SessionChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    message?: boolean
    type?: boolean
    createdAt?: boolean
    session?: boolean | GameSessionDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionChat"]>

  export type SessionChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    message?: boolean
    type?: boolean
    createdAt?: boolean
    session?: boolean | GameSessionDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionChat"]>

  export type SessionChatSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    message?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type SessionChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | GameSessionDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type SessionChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | GameSessionDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $SessionChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionChat"
    objects: {
      session: Prisma.$GameSessionPayload<ExtArgs>
      user: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string
      message: string
      type: $Enums.MessageType
      createdAt: Date
    }, ExtArgs["result"]["sessionChat"]>
    composites: {}
  }

  type SessionChatGetPayload<S extends boolean | null | undefined | SessionChatDefaultArgs> = $Result.GetResult<Prisma.$SessionChatPayload, S>

  type SessionChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionChatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionChatCountAggregateInputType | true
    }

  export interface SessionChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionChat'], meta: { name: 'SessionChat' } }
    /**
     * Find zero or one SessionChat that matches the filter.
     * @param {SessionChatFindUniqueArgs} args - Arguments to find a SessionChat
     * @example
     * // Get one SessionChat
     * const sessionChat = await prisma.sessionChat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionChatFindUniqueArgs>(args: SelectSubset<T, SessionChatFindUniqueArgs<ExtArgs>>): Prisma__SessionChatClient<$Result.GetResult<Prisma.$SessionChatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionChat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionChatFindUniqueOrThrowArgs} args - Arguments to find a SessionChat
     * @example
     * // Get one SessionChat
     * const sessionChat = await prisma.sessionChat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionChatFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionChatClient<$Result.GetResult<Prisma.$SessionChatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionChat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionChatFindFirstArgs} args - Arguments to find a SessionChat
     * @example
     * // Get one SessionChat
     * const sessionChat = await prisma.sessionChat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionChatFindFirstArgs>(args?: SelectSubset<T, SessionChatFindFirstArgs<ExtArgs>>): Prisma__SessionChatClient<$Result.GetResult<Prisma.$SessionChatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionChat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionChatFindFirstOrThrowArgs} args - Arguments to find a SessionChat
     * @example
     * // Get one SessionChat
     * const sessionChat = await prisma.sessionChat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionChatFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionChatClient<$Result.GetResult<Prisma.$SessionChatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionChats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionChats
     * const sessionChats = await prisma.sessionChat.findMany()
     * 
     * // Get first 10 SessionChats
     * const sessionChats = await prisma.sessionChat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionChatWithIdOnly = await prisma.sessionChat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionChatFindManyArgs>(args?: SelectSubset<T, SessionChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionChatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionChat.
     * @param {SessionChatCreateArgs} args - Arguments to create a SessionChat.
     * @example
     * // Create one SessionChat
     * const SessionChat = await prisma.sessionChat.create({
     *   data: {
     *     // ... data to create a SessionChat
     *   }
     * })
     * 
     */
    create<T extends SessionChatCreateArgs>(args: SelectSubset<T, SessionChatCreateArgs<ExtArgs>>): Prisma__SessionChatClient<$Result.GetResult<Prisma.$SessionChatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionChats.
     * @param {SessionChatCreateManyArgs} args - Arguments to create many SessionChats.
     * @example
     * // Create many SessionChats
     * const sessionChat = await prisma.sessionChat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionChatCreateManyArgs>(args?: SelectSubset<T, SessionChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionChats and returns the data saved in the database.
     * @param {SessionChatCreateManyAndReturnArgs} args - Arguments to create many SessionChats.
     * @example
     * // Create many SessionChats
     * const sessionChat = await prisma.sessionChat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionChats and only return the `id`
     * const sessionChatWithIdOnly = await prisma.sessionChat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionChatCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionChatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionChat.
     * @param {SessionChatDeleteArgs} args - Arguments to delete one SessionChat.
     * @example
     * // Delete one SessionChat
     * const SessionChat = await prisma.sessionChat.delete({
     *   where: {
     *     // ... filter to delete one SessionChat
     *   }
     * })
     * 
     */
    delete<T extends SessionChatDeleteArgs>(args: SelectSubset<T, SessionChatDeleteArgs<ExtArgs>>): Prisma__SessionChatClient<$Result.GetResult<Prisma.$SessionChatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionChat.
     * @param {SessionChatUpdateArgs} args - Arguments to update one SessionChat.
     * @example
     * // Update one SessionChat
     * const sessionChat = await prisma.sessionChat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionChatUpdateArgs>(args: SelectSubset<T, SessionChatUpdateArgs<ExtArgs>>): Prisma__SessionChatClient<$Result.GetResult<Prisma.$SessionChatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionChats.
     * @param {SessionChatDeleteManyArgs} args - Arguments to filter SessionChats to delete.
     * @example
     * // Delete a few SessionChats
     * const { count } = await prisma.sessionChat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionChatDeleteManyArgs>(args?: SelectSubset<T, SessionChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionChats
     * const sessionChat = await prisma.sessionChat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionChatUpdateManyArgs>(args: SelectSubset<T, SessionChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionChat.
     * @param {SessionChatUpsertArgs} args - Arguments to update or create a SessionChat.
     * @example
     * // Update or create a SessionChat
     * const sessionChat = await prisma.sessionChat.upsert({
     *   create: {
     *     // ... data to create a SessionChat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionChat we want to update
     *   }
     * })
     */
    upsert<T extends SessionChatUpsertArgs>(args: SelectSubset<T, SessionChatUpsertArgs<ExtArgs>>): Prisma__SessionChatClient<$Result.GetResult<Prisma.$SessionChatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionChats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionChatCountArgs} args - Arguments to filter SessionChats to count.
     * @example
     * // Count the number of SessionChats
     * const count = await prisma.sessionChat.count({
     *   where: {
     *     // ... the filter for the SessionChats we want to count
     *   }
     * })
    **/
    count<T extends SessionChatCountArgs>(
      args?: Subset<T, SessionChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionChatAggregateArgs>(args: Subset<T, SessionChatAggregateArgs>): Prisma.PrismaPromise<GetSessionChatAggregateType<T>>

    /**
     * Group by SessionChat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionChatGroupByArgs['orderBy'] }
        : { orderBy?: SessionChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionChat model
   */
  readonly fields: SessionChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionChat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends GameSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameSessionDefaultArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionChat model
   */ 
  interface SessionChatFieldRefs {
    readonly id: FieldRef<"SessionChat", 'String'>
    readonly sessionId: FieldRef<"SessionChat", 'String'>
    readonly userId: FieldRef<"SessionChat", 'String'>
    readonly message: FieldRef<"SessionChat", 'String'>
    readonly type: FieldRef<"SessionChat", 'MessageType'>
    readonly createdAt: FieldRef<"SessionChat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionChat findUnique
   */
  export type SessionChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionChat
     */
    select?: SessionChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionChatInclude<ExtArgs> | null
    /**
     * Filter, which SessionChat to fetch.
     */
    where: SessionChatWhereUniqueInput
  }

  /**
   * SessionChat findUniqueOrThrow
   */
  export type SessionChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionChat
     */
    select?: SessionChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionChatInclude<ExtArgs> | null
    /**
     * Filter, which SessionChat to fetch.
     */
    where: SessionChatWhereUniqueInput
  }

  /**
   * SessionChat findFirst
   */
  export type SessionChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionChat
     */
    select?: SessionChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionChatInclude<ExtArgs> | null
    /**
     * Filter, which SessionChat to fetch.
     */
    where?: SessionChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionChats to fetch.
     */
    orderBy?: SessionChatOrderByWithRelationInput | SessionChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionChats.
     */
    cursor?: SessionChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionChats.
     */
    distinct?: SessionChatScalarFieldEnum | SessionChatScalarFieldEnum[]
  }

  /**
   * SessionChat findFirstOrThrow
   */
  export type SessionChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionChat
     */
    select?: SessionChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionChatInclude<ExtArgs> | null
    /**
     * Filter, which SessionChat to fetch.
     */
    where?: SessionChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionChats to fetch.
     */
    orderBy?: SessionChatOrderByWithRelationInput | SessionChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionChats.
     */
    cursor?: SessionChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionChats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionChats.
     */
    distinct?: SessionChatScalarFieldEnum | SessionChatScalarFieldEnum[]
  }

  /**
   * SessionChat findMany
   */
  export type SessionChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionChat
     */
    select?: SessionChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionChatInclude<ExtArgs> | null
    /**
     * Filter, which SessionChats to fetch.
     */
    where?: SessionChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionChats to fetch.
     */
    orderBy?: SessionChatOrderByWithRelationInput | SessionChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionChats.
     */
    cursor?: SessionChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionChats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionChats.
     */
    skip?: number
    distinct?: SessionChatScalarFieldEnum | SessionChatScalarFieldEnum[]
  }

  /**
   * SessionChat create
   */
  export type SessionChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionChat
     */
    select?: SessionChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionChatInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionChat.
     */
    data: XOR<SessionChatCreateInput, SessionChatUncheckedCreateInput>
  }

  /**
   * SessionChat createMany
   */
  export type SessionChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionChats.
     */
    data: SessionChatCreateManyInput | SessionChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionChat createManyAndReturn
   */
  export type SessionChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionChat
     */
    select?: SessionChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionChats.
     */
    data: SessionChatCreateManyInput | SessionChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionChat update
   */
  export type SessionChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionChat
     */
    select?: SessionChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionChatInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionChat.
     */
    data: XOR<SessionChatUpdateInput, SessionChatUncheckedUpdateInput>
    /**
     * Choose, which SessionChat to update.
     */
    where: SessionChatWhereUniqueInput
  }

  /**
   * SessionChat updateMany
   */
  export type SessionChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionChats.
     */
    data: XOR<SessionChatUpdateManyMutationInput, SessionChatUncheckedUpdateManyInput>
    /**
     * Filter which SessionChats to update
     */
    where?: SessionChatWhereInput
  }

  /**
   * SessionChat upsert
   */
  export type SessionChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionChat
     */
    select?: SessionChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionChatInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionChat to update in case it exists.
     */
    where: SessionChatWhereUniqueInput
    /**
     * In case the SessionChat found by the `where` argument doesn't exist, create a new SessionChat with this data.
     */
    create: XOR<SessionChatCreateInput, SessionChatUncheckedCreateInput>
    /**
     * In case the SessionChat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionChatUpdateInput, SessionChatUncheckedUpdateInput>
  }

  /**
   * SessionChat delete
   */
  export type SessionChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionChat
     */
    select?: SessionChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionChatInclude<ExtArgs> | null
    /**
     * Filter which SessionChat to delete.
     */
    where: SessionChatWhereUniqueInput
  }

  /**
   * SessionChat deleteMany
   */
  export type SessionChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionChats to delete
     */
    where?: SessionChatWhereInput
  }

  /**
   * SessionChat without action
   */
  export type SessionChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionChat
     */
    select?: SessionChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionChatInclude<ExtArgs> | null
  }


  /**
   * Model UserGameLibrary
   */

  export type AggregateUserGameLibrary = {
    _count: UserGameLibraryCountAggregateOutputType | null
    _avg: UserGameLibraryAvgAggregateOutputType | null
    _sum: UserGameLibrarySumAggregateOutputType | null
    _min: UserGameLibraryMinAggregateOutputType | null
    _max: UserGameLibraryMaxAggregateOutputType | null
  }

  export type UserGameLibraryAvgAggregateOutputType = {
    playTimeMinutes: number | null
    rating: number | null
  }

  export type UserGameLibrarySumAggregateOutputType = {
    playTimeMinutes: number | null
    rating: number | null
  }

  export type UserGameLibraryMinAggregateOutputType = {
    userId: string | null
    gameId: string | null
    status: $Enums.GameStatus | null
    playTimeMinutes: number | null
    lastPlayedAt: Date | null
    rating: number | null
    addedAt: Date | null
  }

  export type UserGameLibraryMaxAggregateOutputType = {
    userId: string | null
    gameId: string | null
    status: $Enums.GameStatus | null
    playTimeMinutes: number | null
    lastPlayedAt: Date | null
    rating: number | null
    addedAt: Date | null
  }

  export type UserGameLibraryCountAggregateOutputType = {
    userId: number
    gameId: number
    status: number
    playTimeMinutes: number
    lastPlayedAt: number
    rating: number
    addedAt: number
    _all: number
  }


  export type UserGameLibraryAvgAggregateInputType = {
    playTimeMinutes?: true
    rating?: true
  }

  export type UserGameLibrarySumAggregateInputType = {
    playTimeMinutes?: true
    rating?: true
  }

  export type UserGameLibraryMinAggregateInputType = {
    userId?: true
    gameId?: true
    status?: true
    playTimeMinutes?: true
    lastPlayedAt?: true
    rating?: true
    addedAt?: true
  }

  export type UserGameLibraryMaxAggregateInputType = {
    userId?: true
    gameId?: true
    status?: true
    playTimeMinutes?: true
    lastPlayedAt?: true
    rating?: true
    addedAt?: true
  }

  export type UserGameLibraryCountAggregateInputType = {
    userId?: true
    gameId?: true
    status?: true
    playTimeMinutes?: true
    lastPlayedAt?: true
    rating?: true
    addedAt?: true
    _all?: true
  }

  export type UserGameLibraryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGameLibrary to aggregate.
     */
    where?: UserGameLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGameLibraries to fetch.
     */
    orderBy?: UserGameLibraryOrderByWithRelationInput | UserGameLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserGameLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGameLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGameLibraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGameLibraries
    **/
    _count?: true | UserGameLibraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserGameLibraryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserGameLibrarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGameLibraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGameLibraryMaxAggregateInputType
  }

  export type GetUserGameLibraryAggregateType<T extends UserGameLibraryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGameLibrary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGameLibrary[P]>
      : GetScalarType<T[P], AggregateUserGameLibrary[P]>
  }




  export type UserGameLibraryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGameLibraryWhereInput
    orderBy?: UserGameLibraryOrderByWithAggregationInput | UserGameLibraryOrderByWithAggregationInput[]
    by: UserGameLibraryScalarFieldEnum[] | UserGameLibraryScalarFieldEnum
    having?: UserGameLibraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGameLibraryCountAggregateInputType | true
    _avg?: UserGameLibraryAvgAggregateInputType
    _sum?: UserGameLibrarySumAggregateInputType
    _min?: UserGameLibraryMinAggregateInputType
    _max?: UserGameLibraryMaxAggregateInputType
  }

  export type UserGameLibraryGroupByOutputType = {
    userId: string
    gameId: string
    status: $Enums.GameStatus
    playTimeMinutes: number
    lastPlayedAt: Date | null
    rating: number | null
    addedAt: Date
    _count: UserGameLibraryCountAggregateOutputType | null
    _avg: UserGameLibraryAvgAggregateOutputType | null
    _sum: UserGameLibrarySumAggregateOutputType | null
    _min: UserGameLibraryMinAggregateOutputType | null
    _max: UserGameLibraryMaxAggregateOutputType | null
  }

  type GetUserGameLibraryGroupByPayload<T extends UserGameLibraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGameLibraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGameLibraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGameLibraryGroupByOutputType[P]>
            : GetScalarType<T[P], UserGameLibraryGroupByOutputType[P]>
        }
      >
    >


  export type UserGameLibrarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    gameId?: boolean
    status?: boolean
    playTimeMinutes?: boolean
    lastPlayedAt?: boolean
    rating?: boolean
    addedAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGameLibrary"]>

  export type UserGameLibrarySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    gameId?: boolean
    status?: boolean
    playTimeMinutes?: boolean
    lastPlayedAt?: boolean
    rating?: boolean
    addedAt?: boolean
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGameLibrary"]>

  export type UserGameLibrarySelectScalar = {
    userId?: boolean
    gameId?: boolean
    status?: boolean
    playTimeMinutes?: boolean
    lastPlayedAt?: boolean
    rating?: boolean
    addedAt?: boolean
  }

  export type UserGameLibraryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type UserGameLibraryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $UserGameLibraryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserGameLibrary"
    objects: {
      user: Prisma.$UserProfilePayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      gameId: string
      status: $Enums.GameStatus
      playTimeMinutes: number
      lastPlayedAt: Date | null
      rating: number | null
      addedAt: Date
    }, ExtArgs["result"]["userGameLibrary"]>
    composites: {}
  }

  type UserGameLibraryGetPayload<S extends boolean | null | undefined | UserGameLibraryDefaultArgs> = $Result.GetResult<Prisma.$UserGameLibraryPayload, S>

  type UserGameLibraryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserGameLibraryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserGameLibraryCountAggregateInputType | true
    }

  export interface UserGameLibraryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserGameLibrary'], meta: { name: 'UserGameLibrary' } }
    /**
     * Find zero or one UserGameLibrary that matches the filter.
     * @param {UserGameLibraryFindUniqueArgs} args - Arguments to find a UserGameLibrary
     * @example
     * // Get one UserGameLibrary
     * const userGameLibrary = await prisma.userGameLibrary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserGameLibraryFindUniqueArgs>(args: SelectSubset<T, UserGameLibraryFindUniqueArgs<ExtArgs>>): Prisma__UserGameLibraryClient<$Result.GetResult<Prisma.$UserGameLibraryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserGameLibrary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserGameLibraryFindUniqueOrThrowArgs} args - Arguments to find a UserGameLibrary
     * @example
     * // Get one UserGameLibrary
     * const userGameLibrary = await prisma.userGameLibrary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserGameLibraryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserGameLibraryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserGameLibraryClient<$Result.GetResult<Prisma.$UserGameLibraryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserGameLibrary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGameLibraryFindFirstArgs} args - Arguments to find a UserGameLibrary
     * @example
     * // Get one UserGameLibrary
     * const userGameLibrary = await prisma.userGameLibrary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserGameLibraryFindFirstArgs>(args?: SelectSubset<T, UserGameLibraryFindFirstArgs<ExtArgs>>): Prisma__UserGameLibraryClient<$Result.GetResult<Prisma.$UserGameLibraryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserGameLibrary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGameLibraryFindFirstOrThrowArgs} args - Arguments to find a UserGameLibrary
     * @example
     * // Get one UserGameLibrary
     * const userGameLibrary = await prisma.userGameLibrary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserGameLibraryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserGameLibraryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserGameLibraryClient<$Result.GetResult<Prisma.$UserGameLibraryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserGameLibraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGameLibraryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGameLibraries
     * const userGameLibraries = await prisma.userGameLibrary.findMany()
     * 
     * // Get first 10 UserGameLibraries
     * const userGameLibraries = await prisma.userGameLibrary.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userGameLibraryWithUserIdOnly = await prisma.userGameLibrary.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserGameLibraryFindManyArgs>(args?: SelectSubset<T, UserGameLibraryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGameLibraryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserGameLibrary.
     * @param {UserGameLibraryCreateArgs} args - Arguments to create a UserGameLibrary.
     * @example
     * // Create one UserGameLibrary
     * const UserGameLibrary = await prisma.userGameLibrary.create({
     *   data: {
     *     // ... data to create a UserGameLibrary
     *   }
     * })
     * 
     */
    create<T extends UserGameLibraryCreateArgs>(args: SelectSubset<T, UserGameLibraryCreateArgs<ExtArgs>>): Prisma__UserGameLibraryClient<$Result.GetResult<Prisma.$UserGameLibraryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserGameLibraries.
     * @param {UserGameLibraryCreateManyArgs} args - Arguments to create many UserGameLibraries.
     * @example
     * // Create many UserGameLibraries
     * const userGameLibrary = await prisma.userGameLibrary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserGameLibraryCreateManyArgs>(args?: SelectSubset<T, UserGameLibraryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserGameLibraries and returns the data saved in the database.
     * @param {UserGameLibraryCreateManyAndReturnArgs} args - Arguments to create many UserGameLibraries.
     * @example
     * // Create many UserGameLibraries
     * const userGameLibrary = await prisma.userGameLibrary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserGameLibraries and only return the `userId`
     * const userGameLibraryWithUserIdOnly = await prisma.userGameLibrary.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserGameLibraryCreateManyAndReturnArgs>(args?: SelectSubset<T, UserGameLibraryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGameLibraryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserGameLibrary.
     * @param {UserGameLibraryDeleteArgs} args - Arguments to delete one UserGameLibrary.
     * @example
     * // Delete one UserGameLibrary
     * const UserGameLibrary = await prisma.userGameLibrary.delete({
     *   where: {
     *     // ... filter to delete one UserGameLibrary
     *   }
     * })
     * 
     */
    delete<T extends UserGameLibraryDeleteArgs>(args: SelectSubset<T, UserGameLibraryDeleteArgs<ExtArgs>>): Prisma__UserGameLibraryClient<$Result.GetResult<Prisma.$UserGameLibraryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserGameLibrary.
     * @param {UserGameLibraryUpdateArgs} args - Arguments to update one UserGameLibrary.
     * @example
     * // Update one UserGameLibrary
     * const userGameLibrary = await prisma.userGameLibrary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserGameLibraryUpdateArgs>(args: SelectSubset<T, UserGameLibraryUpdateArgs<ExtArgs>>): Prisma__UserGameLibraryClient<$Result.GetResult<Prisma.$UserGameLibraryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserGameLibraries.
     * @param {UserGameLibraryDeleteManyArgs} args - Arguments to filter UserGameLibraries to delete.
     * @example
     * // Delete a few UserGameLibraries
     * const { count } = await prisma.userGameLibrary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserGameLibraryDeleteManyArgs>(args?: SelectSubset<T, UserGameLibraryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGameLibraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGameLibraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGameLibraries
     * const userGameLibrary = await prisma.userGameLibrary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserGameLibraryUpdateManyArgs>(args: SelectSubset<T, UserGameLibraryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserGameLibrary.
     * @param {UserGameLibraryUpsertArgs} args - Arguments to update or create a UserGameLibrary.
     * @example
     * // Update or create a UserGameLibrary
     * const userGameLibrary = await prisma.userGameLibrary.upsert({
     *   create: {
     *     // ... data to create a UserGameLibrary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGameLibrary we want to update
     *   }
     * })
     */
    upsert<T extends UserGameLibraryUpsertArgs>(args: SelectSubset<T, UserGameLibraryUpsertArgs<ExtArgs>>): Prisma__UserGameLibraryClient<$Result.GetResult<Prisma.$UserGameLibraryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserGameLibraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGameLibraryCountArgs} args - Arguments to filter UserGameLibraries to count.
     * @example
     * // Count the number of UserGameLibraries
     * const count = await prisma.userGameLibrary.count({
     *   where: {
     *     // ... the filter for the UserGameLibraries we want to count
     *   }
     * })
    **/
    count<T extends UserGameLibraryCountArgs>(
      args?: Subset<T, UserGameLibraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGameLibraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGameLibrary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGameLibraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGameLibraryAggregateArgs>(args: Subset<T, UserGameLibraryAggregateArgs>): Prisma.PrismaPromise<GetUserGameLibraryAggregateType<T>>

    /**
     * Group by UserGameLibrary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGameLibraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGameLibraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGameLibraryGroupByArgs['orderBy'] }
        : { orderBy?: UserGameLibraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGameLibraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGameLibraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserGameLibrary model
   */
  readonly fields: UserGameLibraryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGameLibrary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserGameLibraryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserGameLibrary model
   */ 
  interface UserGameLibraryFieldRefs {
    readonly userId: FieldRef<"UserGameLibrary", 'String'>
    readonly gameId: FieldRef<"UserGameLibrary", 'String'>
    readonly status: FieldRef<"UserGameLibrary", 'GameStatus'>
    readonly playTimeMinutes: FieldRef<"UserGameLibrary", 'Int'>
    readonly lastPlayedAt: FieldRef<"UserGameLibrary", 'DateTime'>
    readonly rating: FieldRef<"UserGameLibrary", 'Int'>
    readonly addedAt: FieldRef<"UserGameLibrary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserGameLibrary findUnique
   */
  export type UserGameLibraryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGameLibrary
     */
    select?: UserGameLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGameLibraryInclude<ExtArgs> | null
    /**
     * Filter, which UserGameLibrary to fetch.
     */
    where: UserGameLibraryWhereUniqueInput
  }

  /**
   * UserGameLibrary findUniqueOrThrow
   */
  export type UserGameLibraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGameLibrary
     */
    select?: UserGameLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGameLibraryInclude<ExtArgs> | null
    /**
     * Filter, which UserGameLibrary to fetch.
     */
    where: UserGameLibraryWhereUniqueInput
  }

  /**
   * UserGameLibrary findFirst
   */
  export type UserGameLibraryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGameLibrary
     */
    select?: UserGameLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGameLibraryInclude<ExtArgs> | null
    /**
     * Filter, which UserGameLibrary to fetch.
     */
    where?: UserGameLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGameLibraries to fetch.
     */
    orderBy?: UserGameLibraryOrderByWithRelationInput | UserGameLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGameLibraries.
     */
    cursor?: UserGameLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGameLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGameLibraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGameLibraries.
     */
    distinct?: UserGameLibraryScalarFieldEnum | UserGameLibraryScalarFieldEnum[]
  }

  /**
   * UserGameLibrary findFirstOrThrow
   */
  export type UserGameLibraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGameLibrary
     */
    select?: UserGameLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGameLibraryInclude<ExtArgs> | null
    /**
     * Filter, which UserGameLibrary to fetch.
     */
    where?: UserGameLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGameLibraries to fetch.
     */
    orderBy?: UserGameLibraryOrderByWithRelationInput | UserGameLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGameLibraries.
     */
    cursor?: UserGameLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGameLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGameLibraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGameLibraries.
     */
    distinct?: UserGameLibraryScalarFieldEnum | UserGameLibraryScalarFieldEnum[]
  }

  /**
   * UserGameLibrary findMany
   */
  export type UserGameLibraryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGameLibrary
     */
    select?: UserGameLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGameLibraryInclude<ExtArgs> | null
    /**
     * Filter, which UserGameLibraries to fetch.
     */
    where?: UserGameLibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGameLibraries to fetch.
     */
    orderBy?: UserGameLibraryOrderByWithRelationInput | UserGameLibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGameLibraries.
     */
    cursor?: UserGameLibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGameLibraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGameLibraries.
     */
    skip?: number
    distinct?: UserGameLibraryScalarFieldEnum | UserGameLibraryScalarFieldEnum[]
  }

  /**
   * UserGameLibrary create
   */
  export type UserGameLibraryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGameLibrary
     */
    select?: UserGameLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGameLibraryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserGameLibrary.
     */
    data: XOR<UserGameLibraryCreateInput, UserGameLibraryUncheckedCreateInput>
  }

  /**
   * UserGameLibrary createMany
   */
  export type UserGameLibraryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserGameLibraries.
     */
    data: UserGameLibraryCreateManyInput | UserGameLibraryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserGameLibrary createManyAndReturn
   */
  export type UserGameLibraryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGameLibrary
     */
    select?: UserGameLibrarySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserGameLibraries.
     */
    data: UserGameLibraryCreateManyInput | UserGameLibraryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGameLibraryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserGameLibrary update
   */
  export type UserGameLibraryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGameLibrary
     */
    select?: UserGameLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGameLibraryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserGameLibrary.
     */
    data: XOR<UserGameLibraryUpdateInput, UserGameLibraryUncheckedUpdateInput>
    /**
     * Choose, which UserGameLibrary to update.
     */
    where: UserGameLibraryWhereUniqueInput
  }

  /**
   * UserGameLibrary updateMany
   */
  export type UserGameLibraryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserGameLibraries.
     */
    data: XOR<UserGameLibraryUpdateManyMutationInput, UserGameLibraryUncheckedUpdateManyInput>
    /**
     * Filter which UserGameLibraries to update
     */
    where?: UserGameLibraryWhereInput
  }

  /**
   * UserGameLibrary upsert
   */
  export type UserGameLibraryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGameLibrary
     */
    select?: UserGameLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGameLibraryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserGameLibrary to update in case it exists.
     */
    where: UserGameLibraryWhereUniqueInput
    /**
     * In case the UserGameLibrary found by the `where` argument doesn't exist, create a new UserGameLibrary with this data.
     */
    create: XOR<UserGameLibraryCreateInput, UserGameLibraryUncheckedCreateInput>
    /**
     * In case the UserGameLibrary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserGameLibraryUpdateInput, UserGameLibraryUncheckedUpdateInput>
  }

  /**
   * UserGameLibrary delete
   */
  export type UserGameLibraryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGameLibrary
     */
    select?: UserGameLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGameLibraryInclude<ExtArgs> | null
    /**
     * Filter which UserGameLibrary to delete.
     */
    where: UserGameLibraryWhereUniqueInput
  }

  /**
   * UserGameLibrary deleteMany
   */
  export type UserGameLibraryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGameLibraries to delete
     */
    where?: UserGameLibraryWhereInput
  }

  /**
   * UserGameLibrary without action
   */
  export type UserGameLibraryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGameLibrary
     */
    select?: UserGameLibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGameLibraryInclude<ExtArgs> | null
  }


  /**
   * Model SessionHistory
   */

  export type AggregateSessionHistory = {
    _count: SessionHistoryCountAggregateOutputType | null
    _avg: SessionHistoryAvgAggregateOutputType | null
    _sum: SessionHistorySumAggregateOutputType | null
    _min: SessionHistoryMinAggregateOutputType | null
    _max: SessionHistoryMaxAggregateOutputType | null
  }

  export type SessionHistoryAvgAggregateOutputType = {
    durationMinutes: number | null
    totalPlayers: number | null
  }

  export type SessionHistorySumAggregateOutputType = {
    durationMinutes: number | null
    totalPlayers: number | null
  }

  export type SessionHistoryMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    gameId: string | null
    role: $Enums.ParticipantRole | null
    startedAt: Date | null
    endedAt: Date | null
    durationMinutes: number | null
    totalPlayers: number | null
  }

  export type SessionHistoryMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    gameId: string | null
    role: $Enums.ParticipantRole | null
    startedAt: Date | null
    endedAt: Date | null
    durationMinutes: number | null
    totalPlayers: number | null
  }

  export type SessionHistoryCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    gameId: number
    role: number
    startedAt: number
    endedAt: number
    durationMinutes: number
    totalPlayers: number
    _all: number
  }


  export type SessionHistoryAvgAggregateInputType = {
    durationMinutes?: true
    totalPlayers?: true
  }

  export type SessionHistorySumAggregateInputType = {
    durationMinutes?: true
    totalPlayers?: true
  }

  export type SessionHistoryMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    gameId?: true
    role?: true
    startedAt?: true
    endedAt?: true
    durationMinutes?: true
    totalPlayers?: true
  }

  export type SessionHistoryMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    gameId?: true
    role?: true
    startedAt?: true
    endedAt?: true
    durationMinutes?: true
    totalPlayers?: true
  }

  export type SessionHistoryCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    gameId?: true
    role?: true
    startedAt?: true
    endedAt?: true
    durationMinutes?: true
    totalPlayers?: true
    _all?: true
  }

  export type SessionHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionHistory to aggregate.
     */
    where?: SessionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionHistories to fetch.
     */
    orderBy?: SessionHistoryOrderByWithRelationInput | SessionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionHistories
    **/
    _count?: true | SessionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionHistoryMaxAggregateInputType
  }

  export type GetSessionHistoryAggregateType<T extends SessionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionHistory[P]>
      : GetScalarType<T[P], AggregateSessionHistory[P]>
  }




  export type SessionHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionHistoryWhereInput
    orderBy?: SessionHistoryOrderByWithAggregationInput | SessionHistoryOrderByWithAggregationInput[]
    by: SessionHistoryScalarFieldEnum[] | SessionHistoryScalarFieldEnum
    having?: SessionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionHistoryCountAggregateInputType | true
    _avg?: SessionHistoryAvgAggregateInputType
    _sum?: SessionHistorySumAggregateInputType
    _min?: SessionHistoryMinAggregateInputType
    _max?: SessionHistoryMaxAggregateInputType
  }

  export type SessionHistoryGroupByOutputType = {
    id: string
    sessionId: string
    userId: string
    gameId: string
    role: $Enums.ParticipantRole
    startedAt: Date
    endedAt: Date
    durationMinutes: number
    totalPlayers: number
    _count: SessionHistoryCountAggregateOutputType | null
    _avg: SessionHistoryAvgAggregateOutputType | null
    _sum: SessionHistorySumAggregateOutputType | null
    _min: SessionHistoryMinAggregateOutputType | null
    _max: SessionHistoryMaxAggregateOutputType | null
  }

  type GetSessionHistoryGroupByPayload<T extends SessionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SessionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SessionHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    gameId?: boolean
    role?: boolean
    startedAt?: boolean
    endedAt?: boolean
    durationMinutes?: boolean
    totalPlayers?: boolean
    session?: boolean | GameSessionDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionHistory"]>

  export type SessionHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    gameId?: boolean
    role?: boolean
    startedAt?: boolean
    endedAt?: boolean
    durationMinutes?: boolean
    totalPlayers?: boolean
    session?: boolean | GameSessionDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionHistory"]>

  export type SessionHistorySelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    gameId?: boolean
    role?: boolean
    startedAt?: boolean
    endedAt?: boolean
    durationMinutes?: boolean
    totalPlayers?: boolean
  }

  export type SessionHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | GameSessionDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }
  export type SessionHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | GameSessionDefaultArgs<ExtArgs>
    user?: boolean | UserProfileDefaultArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
  }

  export type $SessionHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionHistory"
    objects: {
      session: Prisma.$GameSessionPayload<ExtArgs>
      user: Prisma.$UserProfilePayload<ExtArgs>
      game: Prisma.$GamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string
      gameId: string
      role: $Enums.ParticipantRole
      startedAt: Date
      endedAt: Date
      durationMinutes: number
      totalPlayers: number
    }, ExtArgs["result"]["sessionHistory"]>
    composites: {}
  }

  type SessionHistoryGetPayload<S extends boolean | null | undefined | SessionHistoryDefaultArgs> = $Result.GetResult<Prisma.$SessionHistoryPayload, S>

  type SessionHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionHistoryCountAggregateInputType | true
    }

  export interface SessionHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionHistory'], meta: { name: 'SessionHistory' } }
    /**
     * Find zero or one SessionHistory that matches the filter.
     * @param {SessionHistoryFindUniqueArgs} args - Arguments to find a SessionHistory
     * @example
     * // Get one SessionHistory
     * const sessionHistory = await prisma.sessionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionHistoryFindUniqueArgs>(args: SelectSubset<T, SessionHistoryFindUniqueArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionHistoryFindUniqueOrThrowArgs} args - Arguments to find a SessionHistory
     * @example
     * // Get one SessionHistory
     * const sessionHistory = await prisma.sessionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryFindFirstArgs} args - Arguments to find a SessionHistory
     * @example
     * // Get one SessionHistory
     * const sessionHistory = await prisma.sessionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionHistoryFindFirstArgs>(args?: SelectSubset<T, SessionHistoryFindFirstArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryFindFirstOrThrowArgs} args - Arguments to find a SessionHistory
     * @example
     * // Get one SessionHistory
     * const sessionHistory = await prisma.sessionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionHistories
     * const sessionHistories = await prisma.sessionHistory.findMany()
     * 
     * // Get first 10 SessionHistories
     * const sessionHistories = await prisma.sessionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionHistoryWithIdOnly = await prisma.sessionHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionHistoryFindManyArgs>(args?: SelectSubset<T, SessionHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionHistory.
     * @param {SessionHistoryCreateArgs} args - Arguments to create a SessionHistory.
     * @example
     * // Create one SessionHistory
     * const SessionHistory = await prisma.sessionHistory.create({
     *   data: {
     *     // ... data to create a SessionHistory
     *   }
     * })
     * 
     */
    create<T extends SessionHistoryCreateArgs>(args: SelectSubset<T, SessionHistoryCreateArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionHistories.
     * @param {SessionHistoryCreateManyArgs} args - Arguments to create many SessionHistories.
     * @example
     * // Create many SessionHistories
     * const sessionHistory = await prisma.sessionHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionHistoryCreateManyArgs>(args?: SelectSubset<T, SessionHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionHistories and returns the data saved in the database.
     * @param {SessionHistoryCreateManyAndReturnArgs} args - Arguments to create many SessionHistories.
     * @example
     * // Create many SessionHistories
     * const sessionHistory = await prisma.sessionHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionHistories and only return the `id`
     * const sessionHistoryWithIdOnly = await prisma.sessionHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionHistory.
     * @param {SessionHistoryDeleteArgs} args - Arguments to delete one SessionHistory.
     * @example
     * // Delete one SessionHistory
     * const SessionHistory = await prisma.sessionHistory.delete({
     *   where: {
     *     // ... filter to delete one SessionHistory
     *   }
     * })
     * 
     */
    delete<T extends SessionHistoryDeleteArgs>(args: SelectSubset<T, SessionHistoryDeleteArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionHistory.
     * @param {SessionHistoryUpdateArgs} args - Arguments to update one SessionHistory.
     * @example
     * // Update one SessionHistory
     * const sessionHistory = await prisma.sessionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionHistoryUpdateArgs>(args: SelectSubset<T, SessionHistoryUpdateArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionHistories.
     * @param {SessionHistoryDeleteManyArgs} args - Arguments to filter SessionHistories to delete.
     * @example
     * // Delete a few SessionHistories
     * const { count } = await prisma.sessionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionHistoryDeleteManyArgs>(args?: SelectSubset<T, SessionHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionHistories
     * const sessionHistory = await prisma.sessionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionHistoryUpdateManyArgs>(args: SelectSubset<T, SessionHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionHistory.
     * @param {SessionHistoryUpsertArgs} args - Arguments to update or create a SessionHistory.
     * @example
     * // Update or create a SessionHistory
     * const sessionHistory = await prisma.sessionHistory.upsert({
     *   create: {
     *     // ... data to create a SessionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionHistory we want to update
     *   }
     * })
     */
    upsert<T extends SessionHistoryUpsertArgs>(args: SelectSubset<T, SessionHistoryUpsertArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryCountArgs} args - Arguments to filter SessionHistories to count.
     * @example
     * // Count the number of SessionHistories
     * const count = await prisma.sessionHistory.count({
     *   where: {
     *     // ... the filter for the SessionHistories we want to count
     *   }
     * })
    **/
    count<T extends SessionHistoryCountArgs>(
      args?: Subset<T, SessionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionHistoryAggregateArgs>(args: Subset<T, SessionHistoryAggregateArgs>): Prisma.PrismaPromise<GetSessionHistoryAggregateType<T>>

    /**
     * Group by SessionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SessionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionHistory model
   */
  readonly fields: SessionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends GameSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameSessionDefaultArgs<ExtArgs>>): Prisma__GameSessionClient<$Result.GetResult<Prisma.$GameSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionHistory model
   */ 
  interface SessionHistoryFieldRefs {
    readonly id: FieldRef<"SessionHistory", 'String'>
    readonly sessionId: FieldRef<"SessionHistory", 'String'>
    readonly userId: FieldRef<"SessionHistory", 'String'>
    readonly gameId: FieldRef<"SessionHistory", 'String'>
    readonly role: FieldRef<"SessionHistory", 'ParticipantRole'>
    readonly startedAt: FieldRef<"SessionHistory", 'DateTime'>
    readonly endedAt: FieldRef<"SessionHistory", 'DateTime'>
    readonly durationMinutes: FieldRef<"SessionHistory", 'Int'>
    readonly totalPlayers: FieldRef<"SessionHistory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SessionHistory findUnique
   */
  export type SessionHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SessionHistory to fetch.
     */
    where: SessionHistoryWhereUniqueInput
  }

  /**
   * SessionHistory findUniqueOrThrow
   */
  export type SessionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SessionHistory to fetch.
     */
    where: SessionHistoryWhereUniqueInput
  }

  /**
   * SessionHistory findFirst
   */
  export type SessionHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SessionHistory to fetch.
     */
    where?: SessionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionHistories to fetch.
     */
    orderBy?: SessionHistoryOrderByWithRelationInput | SessionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionHistories.
     */
    cursor?: SessionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionHistories.
     */
    distinct?: SessionHistoryScalarFieldEnum | SessionHistoryScalarFieldEnum[]
  }

  /**
   * SessionHistory findFirstOrThrow
   */
  export type SessionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SessionHistory to fetch.
     */
    where?: SessionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionHistories to fetch.
     */
    orderBy?: SessionHistoryOrderByWithRelationInput | SessionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionHistories.
     */
    cursor?: SessionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionHistories.
     */
    distinct?: SessionHistoryScalarFieldEnum | SessionHistoryScalarFieldEnum[]
  }

  /**
   * SessionHistory findMany
   */
  export type SessionHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SessionHistories to fetch.
     */
    where?: SessionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionHistories to fetch.
     */
    orderBy?: SessionHistoryOrderByWithRelationInput | SessionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionHistories.
     */
    cursor?: SessionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionHistories.
     */
    skip?: number
    distinct?: SessionHistoryScalarFieldEnum | SessionHistoryScalarFieldEnum[]
  }

  /**
   * SessionHistory create
   */
  export type SessionHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionHistory.
     */
    data: XOR<SessionHistoryCreateInput, SessionHistoryUncheckedCreateInput>
  }

  /**
   * SessionHistory createMany
   */
  export type SessionHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionHistories.
     */
    data: SessionHistoryCreateManyInput | SessionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionHistory createManyAndReturn
   */
  export type SessionHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionHistories.
     */
    data: SessionHistoryCreateManyInput | SessionHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionHistory update
   */
  export type SessionHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionHistory.
     */
    data: XOR<SessionHistoryUpdateInput, SessionHistoryUncheckedUpdateInput>
    /**
     * Choose, which SessionHistory to update.
     */
    where: SessionHistoryWhereUniqueInput
  }

  /**
   * SessionHistory updateMany
   */
  export type SessionHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionHistories.
     */
    data: XOR<SessionHistoryUpdateManyMutationInput, SessionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SessionHistories to update
     */
    where?: SessionHistoryWhereInput
  }

  /**
   * SessionHistory upsert
   */
  export type SessionHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionHistory to update in case it exists.
     */
    where: SessionHistoryWhereUniqueInput
    /**
     * In case the SessionHistory found by the `where` argument doesn't exist, create a new SessionHistory with this data.
     */
    create: XOR<SessionHistoryCreateInput, SessionHistoryUncheckedCreateInput>
    /**
     * In case the SessionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionHistoryUpdateInput, SessionHistoryUncheckedUpdateInput>
  }

  /**
   * SessionHistory delete
   */
  export type SessionHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * Filter which SessionHistory to delete.
     */
    where: SessionHistoryWhereUniqueInput
  }

  /**
   * SessionHistory deleteMany
   */
  export type SessionHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionHistories to delete
     */
    where?: SessionHistoryWhereInput
  }

  /**
   * SessionHistory without action
   */
  export type SessionHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    platiumUserId: 'platiumUserId',
    username: 'username',
    displayName: 'displayName',
    avatarUrl: 'avatarUrl',
    preferredEmulator: 'preferredEmulator',
    isOnline: 'isOnline',
    lastSeenAt: 'lastSeenAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    system: 'system',
    year: 'year',
    genre: 'genre',
    playerCount: 'playerCount',
    romPath: 'romPath',
    emulator: 'emulator',
    emulatorCore: 'emulatorCore',
    coverArtUrl: 'coverArtUrl',
    screenshotUrls: 'screenshotUrls',
    description: 'description',
    rating: 'rating',
    playCount: 'playCount',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const GameSessionScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    createdBy: 'createdBy',
    sessionCode: 'sessionCode',
    status: 'status',
    sessionType: 'sessionType',
    isPrivate: 'isPrivate',
    maxPlayers: 'maxPlayers',
    currentPlayers: 'currentPlayers',
    spectatorCount: 'spectatorCount',
    containerId: 'containerId',
    containerIp: 'containerIp',
    containerPort: 'containerPort',
    videoQuality: 'videoQuality',
    fps: 'fps',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    lastActivityAt: 'lastActivityAt',
    durationMinutes: 'durationMinutes'
  };

  export type GameSessionScalarFieldEnum = (typeof GameSessionScalarFieldEnum)[keyof typeof GameSessionScalarFieldEnum]


  export const SessionParticipantScalarFieldEnum: {
    sessionId: 'sessionId',
    userId: 'userId',
    role: 'role',
    isHost: 'isHost',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt',
    totalDurationMinutes: 'totalDurationMinutes'
  };

  export type SessionParticipantScalarFieldEnum = (typeof SessionParticipantScalarFieldEnum)[keyof typeof SessionParticipantScalarFieldEnum]


  export const SessionChatScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    message: 'message',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type SessionChatScalarFieldEnum = (typeof SessionChatScalarFieldEnum)[keyof typeof SessionChatScalarFieldEnum]


  export const UserGameLibraryScalarFieldEnum: {
    userId: 'userId',
    gameId: 'gameId',
    status: 'status',
    playTimeMinutes: 'playTimeMinutes',
    lastPlayedAt: 'lastPlayedAt',
    rating: 'rating',
    addedAt: 'addedAt'
  };

  export type UserGameLibraryScalarFieldEnum = (typeof UserGameLibraryScalarFieldEnum)[keyof typeof UserGameLibraryScalarFieldEnum]


  export const SessionHistoryScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    gameId: 'gameId',
    role: 'role',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    durationMinutes: 'durationMinutes',
    totalPlayers: 'totalPlayers'
  };

  export type SessionHistoryScalarFieldEnum = (typeof SessionHistoryScalarFieldEnum)[keyof typeof SessionHistoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'SessionStatus'
   */
  export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


  /**
   * Reference to a field of type 'SessionStatus[]'
   */
  export type ListEnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus[]'>
    


  /**
   * Reference to a field of type 'SessionType'
   */
  export type EnumSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionType'>
    


  /**
   * Reference to a field of type 'SessionType[]'
   */
  export type ListEnumSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionType[]'>
    


  /**
   * Reference to a field of type 'VideoQuality'
   */
  export type EnumVideoQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoQuality'>
    


  /**
   * Reference to a field of type 'VideoQuality[]'
   */
  export type ListEnumVideoQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoQuality[]'>
    


  /**
   * Reference to a field of type 'ParticipantRole'
   */
  export type EnumParticipantRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParticipantRole'>
    


  /**
   * Reference to a field of type 'ParticipantRole[]'
   */
  export type ListEnumParticipantRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParticipantRole[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'GameStatus'
   */
  export type EnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatus'>
    


  /**
   * Reference to a field of type 'GameStatus[]'
   */
  export type ListEnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    platiumUserId?: StringFilter<"UserProfile"> | string
    username?: StringFilter<"UserProfile"> | string
    displayName?: StringNullableFilter<"UserProfile"> | string | null
    avatarUrl?: StringNullableFilter<"UserProfile"> | string | null
    preferredEmulator?: StringNullableFilter<"UserProfile"> | string | null
    isOnline?: BoolFilter<"UserProfile"> | boolean
    lastSeenAt?: DateTimeFilter<"UserProfile"> | Date | string
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    createdSessions?: GameSessionListRelationFilter
    library?: UserGameLibraryListRelationFilter
    participations?: SessionParticipantListRelationFilter
    chatMessages?: SessionChatListRelationFilter
    sessionHistory?: SessionHistoryListRelationFilter
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    platiumUserId?: SortOrder
    username?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    preferredEmulator?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdSessions?: GameSessionOrderByRelationAggregateInput
    library?: UserGameLibraryOrderByRelationAggregateInput
    participations?: SessionParticipantOrderByRelationAggregateInput
    chatMessages?: SessionChatOrderByRelationAggregateInput
    sessionHistory?: SessionHistoryOrderByRelationAggregateInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    platiumUserId?: string
    username?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    displayName?: StringNullableFilter<"UserProfile"> | string | null
    avatarUrl?: StringNullableFilter<"UserProfile"> | string | null
    preferredEmulator?: StringNullableFilter<"UserProfile"> | string | null
    isOnline?: BoolFilter<"UserProfile"> | boolean
    lastSeenAt?: DateTimeFilter<"UserProfile"> | Date | string
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    createdSessions?: GameSessionListRelationFilter
    library?: UserGameLibraryListRelationFilter
    participations?: SessionParticipantListRelationFilter
    chatMessages?: SessionChatListRelationFilter
    sessionHistory?: SessionHistoryListRelationFilter
  }, "id" | "platiumUserId" | "username">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    platiumUserId?: SortOrder
    username?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    preferredEmulator?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    platiumUserId?: StringWithAggregatesFilter<"UserProfile"> | string
    username?: StringWithAggregatesFilter<"UserProfile"> | string
    displayName?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    preferredEmulator?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    isOnline?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    lastSeenAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: StringFilter<"Game"> | string
    title?: StringFilter<"Game"> | string
    slug?: StringFilter<"Game"> | string
    system?: StringFilter<"Game"> | string
    year?: IntNullableFilter<"Game"> | number | null
    genre?: StringNullableFilter<"Game"> | string | null
    playerCount?: IntFilter<"Game"> | number
    romPath?: StringNullableFilter<"Game"> | string | null
    emulator?: StringFilter<"Game"> | string
    emulatorCore?: StringNullableFilter<"Game"> | string | null
    coverArtUrl?: StringNullableFilter<"Game"> | string | null
    screenshotUrls?: StringNullableListFilter<"Game">
    description?: StringNullableFilter<"Game"> | string | null
    rating?: DecimalNullableFilter<"Game"> | Decimal | DecimalJsLike | number | string | null
    playCount?: IntFilter<"Game"> | number
    isActive?: BoolFilter<"Game"> | boolean
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    sessions?: GameSessionListRelationFilter
    libraryEntries?: UserGameLibraryListRelationFilter
    sessionHistory?: SessionHistoryListRelationFilter
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    system?: SortOrder
    year?: SortOrderInput | SortOrder
    genre?: SortOrderInput | SortOrder
    playerCount?: SortOrder
    romPath?: SortOrderInput | SortOrder
    emulator?: SortOrder
    emulatorCore?: SortOrderInput | SortOrder
    coverArtUrl?: SortOrderInput | SortOrder
    screenshotUrls?: SortOrder
    description?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    playCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: GameSessionOrderByRelationAggregateInput
    libraryEntries?: UserGameLibraryOrderByRelationAggregateInput
    sessionHistory?: SessionHistoryOrderByRelationAggregateInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    title?: StringFilter<"Game"> | string
    system?: StringFilter<"Game"> | string
    year?: IntNullableFilter<"Game"> | number | null
    genre?: StringNullableFilter<"Game"> | string | null
    playerCount?: IntFilter<"Game"> | number
    romPath?: StringNullableFilter<"Game"> | string | null
    emulator?: StringFilter<"Game"> | string
    emulatorCore?: StringNullableFilter<"Game"> | string | null
    coverArtUrl?: StringNullableFilter<"Game"> | string | null
    screenshotUrls?: StringNullableListFilter<"Game">
    description?: StringNullableFilter<"Game"> | string | null
    rating?: DecimalNullableFilter<"Game"> | Decimal | DecimalJsLike | number | string | null
    playCount?: IntFilter<"Game"> | number
    isActive?: BoolFilter<"Game"> | boolean
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    sessions?: GameSessionListRelationFilter
    libraryEntries?: UserGameLibraryListRelationFilter
    sessionHistory?: SessionHistoryListRelationFilter
  }, "id" | "slug">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    system?: SortOrder
    year?: SortOrderInput | SortOrder
    genre?: SortOrderInput | SortOrder
    playerCount?: SortOrder
    romPath?: SortOrderInput | SortOrder
    emulator?: SortOrder
    emulatorCore?: SortOrderInput | SortOrder
    coverArtUrl?: SortOrderInput | SortOrder
    screenshotUrls?: SortOrder
    description?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    playCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Game"> | string
    title?: StringWithAggregatesFilter<"Game"> | string
    slug?: StringWithAggregatesFilter<"Game"> | string
    system?: StringWithAggregatesFilter<"Game"> | string
    year?: IntNullableWithAggregatesFilter<"Game"> | number | null
    genre?: StringNullableWithAggregatesFilter<"Game"> | string | null
    playerCount?: IntWithAggregatesFilter<"Game"> | number
    romPath?: StringNullableWithAggregatesFilter<"Game"> | string | null
    emulator?: StringWithAggregatesFilter<"Game"> | string
    emulatorCore?: StringNullableWithAggregatesFilter<"Game"> | string | null
    coverArtUrl?: StringNullableWithAggregatesFilter<"Game"> | string | null
    screenshotUrls?: StringNullableListFilter<"Game">
    description?: StringNullableWithAggregatesFilter<"Game"> | string | null
    rating?: DecimalNullableWithAggregatesFilter<"Game"> | Decimal | DecimalJsLike | number | string | null
    playCount?: IntWithAggregatesFilter<"Game"> | number
    isActive?: BoolWithAggregatesFilter<"Game"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
  }

  export type GameSessionWhereInput = {
    AND?: GameSessionWhereInput | GameSessionWhereInput[]
    OR?: GameSessionWhereInput[]
    NOT?: GameSessionWhereInput | GameSessionWhereInput[]
    id?: StringFilter<"GameSession"> | string
    gameId?: StringFilter<"GameSession"> | string
    createdBy?: StringFilter<"GameSession"> | string
    sessionCode?: StringNullableFilter<"GameSession"> | string | null
    status?: EnumSessionStatusFilter<"GameSession"> | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFilter<"GameSession"> | $Enums.SessionType
    isPrivate?: BoolFilter<"GameSession"> | boolean
    maxPlayers?: IntFilter<"GameSession"> | number
    currentPlayers?: IntFilter<"GameSession"> | number
    spectatorCount?: IntFilter<"GameSession"> | number
    containerId?: StringNullableFilter<"GameSession"> | string | null
    containerIp?: StringNullableFilter<"GameSession"> | string | null
    containerPort?: IntNullableFilter<"GameSession"> | number | null
    videoQuality?: EnumVideoQualityFilter<"GameSession"> | $Enums.VideoQuality
    fps?: IntFilter<"GameSession"> | number
    startedAt?: DateTimeFilter<"GameSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    lastActivityAt?: DateTimeFilter<"GameSession"> | Date | string
    durationMinutes?: IntNullableFilter<"GameSession"> | number | null
    game?: XOR<GameRelationFilter, GameWhereInput>
    creator?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    participants?: SessionParticipantListRelationFilter
    chatMessages?: SessionChatListRelationFilter
    history?: SessionHistoryListRelationFilter
  }

  export type GameSessionOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    createdBy?: SortOrder
    sessionCode?: SortOrderInput | SortOrder
    status?: SortOrder
    sessionType?: SortOrder
    isPrivate?: SortOrder
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
    spectatorCount?: SortOrder
    containerId?: SortOrderInput | SortOrder
    containerIp?: SortOrderInput | SortOrder
    containerPort?: SortOrderInput | SortOrder
    videoQuality?: SortOrder
    fps?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    lastActivityAt?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    game?: GameOrderByWithRelationInput
    creator?: UserProfileOrderByWithRelationInput
    participants?: SessionParticipantOrderByRelationAggregateInput
    chatMessages?: SessionChatOrderByRelationAggregateInput
    history?: SessionHistoryOrderByRelationAggregateInput
  }

  export type GameSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionCode?: string
    AND?: GameSessionWhereInput | GameSessionWhereInput[]
    OR?: GameSessionWhereInput[]
    NOT?: GameSessionWhereInput | GameSessionWhereInput[]
    gameId?: StringFilter<"GameSession"> | string
    createdBy?: StringFilter<"GameSession"> | string
    status?: EnumSessionStatusFilter<"GameSession"> | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFilter<"GameSession"> | $Enums.SessionType
    isPrivate?: BoolFilter<"GameSession"> | boolean
    maxPlayers?: IntFilter<"GameSession"> | number
    currentPlayers?: IntFilter<"GameSession"> | number
    spectatorCount?: IntFilter<"GameSession"> | number
    containerId?: StringNullableFilter<"GameSession"> | string | null
    containerIp?: StringNullableFilter<"GameSession"> | string | null
    containerPort?: IntNullableFilter<"GameSession"> | number | null
    videoQuality?: EnumVideoQualityFilter<"GameSession"> | $Enums.VideoQuality
    fps?: IntFilter<"GameSession"> | number
    startedAt?: DateTimeFilter<"GameSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    lastActivityAt?: DateTimeFilter<"GameSession"> | Date | string
    durationMinutes?: IntNullableFilter<"GameSession"> | number | null
    game?: XOR<GameRelationFilter, GameWhereInput>
    creator?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    participants?: SessionParticipantListRelationFilter
    chatMessages?: SessionChatListRelationFilter
    history?: SessionHistoryListRelationFilter
  }, "id" | "sessionCode">

  export type GameSessionOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    createdBy?: SortOrder
    sessionCode?: SortOrderInput | SortOrder
    status?: SortOrder
    sessionType?: SortOrder
    isPrivate?: SortOrder
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
    spectatorCount?: SortOrder
    containerId?: SortOrderInput | SortOrder
    containerIp?: SortOrderInput | SortOrder
    containerPort?: SortOrderInput | SortOrder
    videoQuality?: SortOrder
    fps?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    lastActivityAt?: SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    _count?: GameSessionCountOrderByAggregateInput
    _avg?: GameSessionAvgOrderByAggregateInput
    _max?: GameSessionMaxOrderByAggregateInput
    _min?: GameSessionMinOrderByAggregateInput
    _sum?: GameSessionSumOrderByAggregateInput
  }

  export type GameSessionScalarWhereWithAggregatesInput = {
    AND?: GameSessionScalarWhereWithAggregatesInput | GameSessionScalarWhereWithAggregatesInput[]
    OR?: GameSessionScalarWhereWithAggregatesInput[]
    NOT?: GameSessionScalarWhereWithAggregatesInput | GameSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameSession"> | string
    gameId?: StringWithAggregatesFilter<"GameSession"> | string
    createdBy?: StringWithAggregatesFilter<"GameSession"> | string
    sessionCode?: StringNullableWithAggregatesFilter<"GameSession"> | string | null
    status?: EnumSessionStatusWithAggregatesFilter<"GameSession"> | $Enums.SessionStatus
    sessionType?: EnumSessionTypeWithAggregatesFilter<"GameSession"> | $Enums.SessionType
    isPrivate?: BoolWithAggregatesFilter<"GameSession"> | boolean
    maxPlayers?: IntWithAggregatesFilter<"GameSession"> | number
    currentPlayers?: IntWithAggregatesFilter<"GameSession"> | number
    spectatorCount?: IntWithAggregatesFilter<"GameSession"> | number
    containerId?: StringNullableWithAggregatesFilter<"GameSession"> | string | null
    containerIp?: StringNullableWithAggregatesFilter<"GameSession"> | string | null
    containerPort?: IntNullableWithAggregatesFilter<"GameSession"> | number | null
    videoQuality?: EnumVideoQualityWithAggregatesFilter<"GameSession"> | $Enums.VideoQuality
    fps?: IntWithAggregatesFilter<"GameSession"> | number
    startedAt?: DateTimeWithAggregatesFilter<"GameSession"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"GameSession"> | Date | string | null
    lastActivityAt?: DateTimeWithAggregatesFilter<"GameSession"> | Date | string
    durationMinutes?: IntNullableWithAggregatesFilter<"GameSession"> | number | null
  }

  export type SessionParticipantWhereInput = {
    AND?: SessionParticipantWhereInput | SessionParticipantWhereInput[]
    OR?: SessionParticipantWhereInput[]
    NOT?: SessionParticipantWhereInput | SessionParticipantWhereInput[]
    sessionId?: StringFilter<"SessionParticipant"> | string
    userId?: StringFilter<"SessionParticipant"> | string
    role?: EnumParticipantRoleFilter<"SessionParticipant"> | $Enums.ParticipantRole
    isHost?: BoolFilter<"SessionParticipant"> | boolean
    joinedAt?: DateTimeFilter<"SessionParticipant"> | Date | string
    leftAt?: DateTimeNullableFilter<"SessionParticipant"> | Date | string | null
    totalDurationMinutes?: IntFilter<"SessionParticipant"> | number
    session?: XOR<GameSessionRelationFilter, GameSessionWhereInput>
    user?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }

  export type SessionParticipantOrderByWithRelationInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isHost?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    totalDurationMinutes?: SortOrder
    session?: GameSessionOrderByWithRelationInput
    user?: UserProfileOrderByWithRelationInput
  }

  export type SessionParticipantWhereUniqueInput = Prisma.AtLeast<{
    sessionId_userId?: SessionParticipantSessionIdUserIdCompoundUniqueInput
    AND?: SessionParticipantWhereInput | SessionParticipantWhereInput[]
    OR?: SessionParticipantWhereInput[]
    NOT?: SessionParticipantWhereInput | SessionParticipantWhereInput[]
    sessionId?: StringFilter<"SessionParticipant"> | string
    userId?: StringFilter<"SessionParticipant"> | string
    role?: EnumParticipantRoleFilter<"SessionParticipant"> | $Enums.ParticipantRole
    isHost?: BoolFilter<"SessionParticipant"> | boolean
    joinedAt?: DateTimeFilter<"SessionParticipant"> | Date | string
    leftAt?: DateTimeNullableFilter<"SessionParticipant"> | Date | string | null
    totalDurationMinutes?: IntFilter<"SessionParticipant"> | number
    session?: XOR<GameSessionRelationFilter, GameSessionWhereInput>
    user?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }, "sessionId_userId">

  export type SessionParticipantOrderByWithAggregationInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isHost?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    totalDurationMinutes?: SortOrder
    _count?: SessionParticipantCountOrderByAggregateInput
    _avg?: SessionParticipantAvgOrderByAggregateInput
    _max?: SessionParticipantMaxOrderByAggregateInput
    _min?: SessionParticipantMinOrderByAggregateInput
    _sum?: SessionParticipantSumOrderByAggregateInput
  }

  export type SessionParticipantScalarWhereWithAggregatesInput = {
    AND?: SessionParticipantScalarWhereWithAggregatesInput | SessionParticipantScalarWhereWithAggregatesInput[]
    OR?: SessionParticipantScalarWhereWithAggregatesInput[]
    NOT?: SessionParticipantScalarWhereWithAggregatesInput | SessionParticipantScalarWhereWithAggregatesInput[]
    sessionId?: StringWithAggregatesFilter<"SessionParticipant"> | string
    userId?: StringWithAggregatesFilter<"SessionParticipant"> | string
    role?: EnumParticipantRoleWithAggregatesFilter<"SessionParticipant"> | $Enums.ParticipantRole
    isHost?: BoolWithAggregatesFilter<"SessionParticipant"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"SessionParticipant"> | Date | string
    leftAt?: DateTimeNullableWithAggregatesFilter<"SessionParticipant"> | Date | string | null
    totalDurationMinutes?: IntWithAggregatesFilter<"SessionParticipant"> | number
  }

  export type SessionChatWhereInput = {
    AND?: SessionChatWhereInput | SessionChatWhereInput[]
    OR?: SessionChatWhereInput[]
    NOT?: SessionChatWhereInput | SessionChatWhereInput[]
    id?: StringFilter<"SessionChat"> | string
    sessionId?: StringFilter<"SessionChat"> | string
    userId?: StringFilter<"SessionChat"> | string
    message?: StringFilter<"SessionChat"> | string
    type?: EnumMessageTypeFilter<"SessionChat"> | $Enums.MessageType
    createdAt?: DateTimeFilter<"SessionChat"> | Date | string
    session?: XOR<GameSessionRelationFilter, GameSessionWhereInput>
    user?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }

  export type SessionChatOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    session?: GameSessionOrderByWithRelationInput
    user?: UserProfileOrderByWithRelationInput
  }

  export type SessionChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionChatWhereInput | SessionChatWhereInput[]
    OR?: SessionChatWhereInput[]
    NOT?: SessionChatWhereInput | SessionChatWhereInput[]
    sessionId?: StringFilter<"SessionChat"> | string
    userId?: StringFilter<"SessionChat"> | string
    message?: StringFilter<"SessionChat"> | string
    type?: EnumMessageTypeFilter<"SessionChat"> | $Enums.MessageType
    createdAt?: DateTimeFilter<"SessionChat"> | Date | string
    session?: XOR<GameSessionRelationFilter, GameSessionWhereInput>
    user?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }, "id">

  export type SessionChatOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: SessionChatCountOrderByAggregateInput
    _max?: SessionChatMaxOrderByAggregateInput
    _min?: SessionChatMinOrderByAggregateInput
  }

  export type SessionChatScalarWhereWithAggregatesInput = {
    AND?: SessionChatScalarWhereWithAggregatesInput | SessionChatScalarWhereWithAggregatesInput[]
    OR?: SessionChatScalarWhereWithAggregatesInput[]
    NOT?: SessionChatScalarWhereWithAggregatesInput | SessionChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionChat"> | string
    sessionId?: StringWithAggregatesFilter<"SessionChat"> | string
    userId?: StringWithAggregatesFilter<"SessionChat"> | string
    message?: StringWithAggregatesFilter<"SessionChat"> | string
    type?: EnumMessageTypeWithAggregatesFilter<"SessionChat"> | $Enums.MessageType
    createdAt?: DateTimeWithAggregatesFilter<"SessionChat"> | Date | string
  }

  export type UserGameLibraryWhereInput = {
    AND?: UserGameLibraryWhereInput | UserGameLibraryWhereInput[]
    OR?: UserGameLibraryWhereInput[]
    NOT?: UserGameLibraryWhereInput | UserGameLibraryWhereInput[]
    userId?: StringFilter<"UserGameLibrary"> | string
    gameId?: StringFilter<"UserGameLibrary"> | string
    status?: EnumGameStatusFilter<"UserGameLibrary"> | $Enums.GameStatus
    playTimeMinutes?: IntFilter<"UserGameLibrary"> | number
    lastPlayedAt?: DateTimeNullableFilter<"UserGameLibrary"> | Date | string | null
    rating?: IntNullableFilter<"UserGameLibrary"> | number | null
    addedAt?: DateTimeFilter<"UserGameLibrary"> | Date | string
    user?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type UserGameLibraryOrderByWithRelationInput = {
    userId?: SortOrder
    gameId?: SortOrder
    status?: SortOrder
    playTimeMinutes?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    user?: UserProfileOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type UserGameLibraryWhereUniqueInput = Prisma.AtLeast<{
    userId_gameId?: UserGameLibraryUserIdGameIdCompoundUniqueInput
    AND?: UserGameLibraryWhereInput | UserGameLibraryWhereInput[]
    OR?: UserGameLibraryWhereInput[]
    NOT?: UserGameLibraryWhereInput | UserGameLibraryWhereInput[]
    userId?: StringFilter<"UserGameLibrary"> | string
    gameId?: StringFilter<"UserGameLibrary"> | string
    status?: EnumGameStatusFilter<"UserGameLibrary"> | $Enums.GameStatus
    playTimeMinutes?: IntFilter<"UserGameLibrary"> | number
    lastPlayedAt?: DateTimeNullableFilter<"UserGameLibrary"> | Date | string | null
    rating?: IntNullableFilter<"UserGameLibrary"> | number | null
    addedAt?: DateTimeFilter<"UserGameLibrary"> | Date | string
    user?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "userId_gameId">

  export type UserGameLibraryOrderByWithAggregationInput = {
    userId?: SortOrder
    gameId?: SortOrder
    status?: SortOrder
    playTimeMinutes?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    _count?: UserGameLibraryCountOrderByAggregateInput
    _avg?: UserGameLibraryAvgOrderByAggregateInput
    _max?: UserGameLibraryMaxOrderByAggregateInput
    _min?: UserGameLibraryMinOrderByAggregateInput
    _sum?: UserGameLibrarySumOrderByAggregateInput
  }

  export type UserGameLibraryScalarWhereWithAggregatesInput = {
    AND?: UserGameLibraryScalarWhereWithAggregatesInput | UserGameLibraryScalarWhereWithAggregatesInput[]
    OR?: UserGameLibraryScalarWhereWithAggregatesInput[]
    NOT?: UserGameLibraryScalarWhereWithAggregatesInput | UserGameLibraryScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserGameLibrary"> | string
    gameId?: StringWithAggregatesFilter<"UserGameLibrary"> | string
    status?: EnumGameStatusWithAggregatesFilter<"UserGameLibrary"> | $Enums.GameStatus
    playTimeMinutes?: IntWithAggregatesFilter<"UserGameLibrary"> | number
    lastPlayedAt?: DateTimeNullableWithAggregatesFilter<"UserGameLibrary"> | Date | string | null
    rating?: IntNullableWithAggregatesFilter<"UserGameLibrary"> | number | null
    addedAt?: DateTimeWithAggregatesFilter<"UserGameLibrary"> | Date | string
  }

  export type SessionHistoryWhereInput = {
    AND?: SessionHistoryWhereInput | SessionHistoryWhereInput[]
    OR?: SessionHistoryWhereInput[]
    NOT?: SessionHistoryWhereInput | SessionHistoryWhereInput[]
    id?: StringFilter<"SessionHistory"> | string
    sessionId?: StringFilter<"SessionHistory"> | string
    userId?: StringFilter<"SessionHistory"> | string
    gameId?: StringFilter<"SessionHistory"> | string
    role?: EnumParticipantRoleFilter<"SessionHistory"> | $Enums.ParticipantRole
    startedAt?: DateTimeFilter<"SessionHistory"> | Date | string
    endedAt?: DateTimeFilter<"SessionHistory"> | Date | string
    durationMinutes?: IntFilter<"SessionHistory"> | number
    totalPlayers?: IntFilter<"SessionHistory"> | number
    session?: XOR<GameSessionRelationFilter, GameSessionWhereInput>
    user?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }

  export type SessionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    role?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    durationMinutes?: SortOrder
    totalPlayers?: SortOrder
    session?: GameSessionOrderByWithRelationInput
    user?: UserProfileOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type SessionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionHistoryWhereInput | SessionHistoryWhereInput[]
    OR?: SessionHistoryWhereInput[]
    NOT?: SessionHistoryWhereInput | SessionHistoryWhereInput[]
    sessionId?: StringFilter<"SessionHistory"> | string
    userId?: StringFilter<"SessionHistory"> | string
    gameId?: StringFilter<"SessionHistory"> | string
    role?: EnumParticipantRoleFilter<"SessionHistory"> | $Enums.ParticipantRole
    startedAt?: DateTimeFilter<"SessionHistory"> | Date | string
    endedAt?: DateTimeFilter<"SessionHistory"> | Date | string
    durationMinutes?: IntFilter<"SessionHistory"> | number
    totalPlayers?: IntFilter<"SessionHistory"> | number
    session?: XOR<GameSessionRelationFilter, GameSessionWhereInput>
    user?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    game?: XOR<GameRelationFilter, GameWhereInput>
  }, "id">

  export type SessionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    role?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    durationMinutes?: SortOrder
    totalPlayers?: SortOrder
    _count?: SessionHistoryCountOrderByAggregateInput
    _avg?: SessionHistoryAvgOrderByAggregateInput
    _max?: SessionHistoryMaxOrderByAggregateInput
    _min?: SessionHistoryMinOrderByAggregateInput
    _sum?: SessionHistorySumOrderByAggregateInput
  }

  export type SessionHistoryScalarWhereWithAggregatesInput = {
    AND?: SessionHistoryScalarWhereWithAggregatesInput | SessionHistoryScalarWhereWithAggregatesInput[]
    OR?: SessionHistoryScalarWhereWithAggregatesInput[]
    NOT?: SessionHistoryScalarWhereWithAggregatesInput | SessionHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionHistory"> | string
    sessionId?: StringWithAggregatesFilter<"SessionHistory"> | string
    userId?: StringWithAggregatesFilter<"SessionHistory"> | string
    gameId?: StringWithAggregatesFilter<"SessionHistory"> | string
    role?: EnumParticipantRoleWithAggregatesFilter<"SessionHistory"> | $Enums.ParticipantRole
    startedAt?: DateTimeWithAggregatesFilter<"SessionHistory"> | Date | string
    endedAt?: DateTimeWithAggregatesFilter<"SessionHistory"> | Date | string
    durationMinutes?: IntWithAggregatesFilter<"SessionHistory"> | number
    totalPlayers?: IntWithAggregatesFilter<"SessionHistory"> | number
  }

  export type UserProfileCreateInput = {
    id?: string
    platiumUserId: string
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    preferredEmulator?: string | null
    isOnline?: boolean
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSessions?: GameSessionCreateNestedManyWithoutCreatorInput
    library?: UserGameLibraryCreateNestedManyWithoutUserInput
    participations?: SessionParticipantCreateNestedManyWithoutUserInput
    chatMessages?: SessionChatCreateNestedManyWithoutUserInput
    sessionHistory?: SessionHistoryCreateNestedManyWithoutUserInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    platiumUserId: string
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    preferredEmulator?: string | null
    isOnline?: boolean
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSessions?: GameSessionUncheckedCreateNestedManyWithoutCreatorInput
    library?: UserGameLibraryUncheckedCreateNestedManyWithoutUserInput
    participations?: SessionParticipantUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: SessionChatUncheckedCreateNestedManyWithoutUserInput
    sessionHistory?: SessionHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSessions?: GameSessionUpdateManyWithoutCreatorNestedInput
    library?: UserGameLibraryUpdateManyWithoutUserNestedInput
    participations?: SessionParticipantUpdateManyWithoutUserNestedInput
    chatMessages?: SessionChatUpdateManyWithoutUserNestedInput
    sessionHistory?: SessionHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSessions?: GameSessionUncheckedUpdateManyWithoutCreatorNestedInput
    library?: UserGameLibraryUncheckedUpdateManyWithoutUserNestedInput
    participations?: SessionParticipantUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: SessionChatUncheckedUpdateManyWithoutUserNestedInput
    sessionHistory?: SessionHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserProfileCreateManyInput = {
    id?: string
    platiumUserId: string
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    preferredEmulator?: string | null
    isOnline?: boolean
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameCreateInput = {
    id?: string
    title: string
    slug: string
    system: string
    year?: number | null
    genre?: string | null
    playerCount?: number
    romPath?: string | null
    emulator?: string
    emulatorCore?: string | null
    coverArtUrl?: string | null
    screenshotUrls?: GameCreatescreenshotUrlsInput | string[]
    description?: string | null
    rating?: Decimal | DecimalJsLike | number | string | null
    playCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    libraryEntries?: UserGameLibraryCreateNestedManyWithoutGameInput
    sessionHistory?: SessionHistoryCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    system: string
    year?: number | null
    genre?: string | null
    playerCount?: number
    romPath?: string | null
    emulator?: string
    emulatorCore?: string | null
    coverArtUrl?: string | null
    screenshotUrls?: GameCreatescreenshotUrlsInput | string[]
    description?: string | null
    rating?: Decimal | DecimalJsLike | number | string | null
    playCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    libraryEntries?: UserGameLibraryUncheckedCreateNestedManyWithoutGameInput
    sessionHistory?: SessionHistoryUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    playerCount?: IntFieldUpdateOperationsInput | number
    romPath?: NullableStringFieldUpdateOperationsInput | string | null
    emulator?: StringFieldUpdateOperationsInput | string
    emulatorCore?: NullableStringFieldUpdateOperationsInput | string | null
    coverArtUrl?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotUrls?: GameUpdatescreenshotUrlsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    playCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    libraryEntries?: UserGameLibraryUpdateManyWithoutGameNestedInput
    sessionHistory?: SessionHistoryUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    playerCount?: IntFieldUpdateOperationsInput | number
    romPath?: NullableStringFieldUpdateOperationsInput | string | null
    emulator?: StringFieldUpdateOperationsInput | string
    emulatorCore?: NullableStringFieldUpdateOperationsInput | string | null
    coverArtUrl?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotUrls?: GameUpdatescreenshotUrlsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    playCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    libraryEntries?: UserGameLibraryUncheckedUpdateManyWithoutGameNestedInput
    sessionHistory?: SessionHistoryUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateManyInput = {
    id?: string
    title: string
    slug: string
    system: string
    year?: number | null
    genre?: string | null
    playerCount?: number
    romPath?: string | null
    emulator?: string
    emulatorCore?: string | null
    coverArtUrl?: string | null
    screenshotUrls?: GameCreatescreenshotUrlsInput | string[]
    description?: string | null
    rating?: Decimal | DecimalJsLike | number | string | null
    playCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    playerCount?: IntFieldUpdateOperationsInput | number
    romPath?: NullableStringFieldUpdateOperationsInput | string | null
    emulator?: StringFieldUpdateOperationsInput | string
    emulatorCore?: NullableStringFieldUpdateOperationsInput | string | null
    coverArtUrl?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotUrls?: GameUpdatescreenshotUrlsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    playCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    playerCount?: IntFieldUpdateOperationsInput | number
    romPath?: NullableStringFieldUpdateOperationsInput | string | null
    emulator?: StringFieldUpdateOperationsInput | string
    emulatorCore?: NullableStringFieldUpdateOperationsInput | string | null
    coverArtUrl?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotUrls?: GameUpdatescreenshotUrlsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    playCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameSessionCreateInput = {
    id?: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
    game: GameCreateNestedOneWithoutSessionsInput
    creator: UserProfileCreateNestedOneWithoutCreatedSessionsInput
    participants?: SessionParticipantCreateNestedManyWithoutSessionInput
    chatMessages?: SessionChatCreateNestedManyWithoutSessionInput
    history?: SessionHistoryCreateNestedManyWithoutSessionInput
  }

  export type GameSessionUncheckedCreateInput = {
    id?: string
    gameId: string
    createdBy: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
    participants?: SessionParticipantUncheckedCreateNestedManyWithoutSessionInput
    chatMessages?: SessionChatUncheckedCreateNestedManyWithoutSessionInput
    history?: SessionHistoryUncheckedCreateNestedManyWithoutSessionInput
  }

  export type GameSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    game?: GameUpdateOneRequiredWithoutSessionsNestedInput
    creator?: UserProfileUpdateOneRequiredWithoutCreatedSessionsNestedInput
    participants?: SessionParticipantUpdateManyWithoutSessionNestedInput
    chatMessages?: SessionChatUpdateManyWithoutSessionNestedInput
    history?: SessionHistoryUpdateManyWithoutSessionNestedInput
  }

  export type GameSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    participants?: SessionParticipantUncheckedUpdateManyWithoutSessionNestedInput
    chatMessages?: SessionChatUncheckedUpdateManyWithoutSessionNestedInput
    history?: SessionHistoryUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type GameSessionCreateManyInput = {
    id?: string
    gameId: string
    createdBy: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
  }

  export type GameSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GameSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SessionParticipantCreateInput = {
    role?: $Enums.ParticipantRole
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    totalDurationMinutes?: number
    session: GameSessionCreateNestedOneWithoutParticipantsInput
    user: UserProfileCreateNestedOneWithoutParticipationsInput
  }

  export type SessionParticipantUncheckedCreateInput = {
    sessionId: string
    userId: string
    role?: $Enums.ParticipantRole
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    totalDurationMinutes?: number
  }

  export type SessionParticipantUpdateInput = {
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    session?: GameSessionUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserProfileUpdateOneRequiredWithoutParticipationsNestedInput
  }

  export type SessionParticipantUncheckedUpdateInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
  }

  export type SessionParticipantCreateManyInput = {
    sessionId: string
    userId: string
    role?: $Enums.ParticipantRole
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    totalDurationMinutes?: number
  }

  export type SessionParticipantUpdateManyMutationInput = {
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
  }

  export type SessionParticipantUncheckedUpdateManyInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
  }

  export type SessionChatCreateInput = {
    id?: string
    message: string
    type?: $Enums.MessageType
    createdAt?: Date | string
    session: GameSessionCreateNestedOneWithoutChatMessagesInput
    user: UserProfileCreateNestedOneWithoutChatMessagesInput
  }

  export type SessionChatUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId: string
    message: string
    type?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type SessionChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: GameSessionUpdateOneRequiredWithoutChatMessagesNestedInput
    user?: UserProfileUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type SessionChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionChatCreateManyInput = {
    id?: string
    sessionId: string
    userId: string
    message: string
    type?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type SessionChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGameLibraryCreateInput = {
    status?: $Enums.GameStatus
    playTimeMinutes?: number
    lastPlayedAt?: Date | string | null
    rating?: number | null
    addedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutLibraryInput
    game: GameCreateNestedOneWithoutLibraryEntriesInput
  }

  export type UserGameLibraryUncheckedCreateInput = {
    userId: string
    gameId: string
    status?: $Enums.GameStatus
    playTimeMinutes?: number
    lastPlayedAt?: Date | string | null
    rating?: number | null
    addedAt?: Date | string
  }

  export type UserGameLibraryUpdateInput = {
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    playTimeMinutes?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutLibraryNestedInput
    game?: GameUpdateOneRequiredWithoutLibraryEntriesNestedInput
  }

  export type UserGameLibraryUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    playTimeMinutes?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGameLibraryCreateManyInput = {
    userId: string
    gameId: string
    status?: $Enums.GameStatus
    playTimeMinutes?: number
    lastPlayedAt?: Date | string | null
    rating?: number | null
    addedAt?: Date | string
  }

  export type UserGameLibraryUpdateManyMutationInput = {
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    playTimeMinutes?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGameLibraryUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    playTimeMinutes?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionHistoryCreateInput = {
    id?: string
    role: $Enums.ParticipantRole
    startedAt: Date | string
    endedAt: Date | string
    durationMinutes: number
    totalPlayers?: number
    session: GameSessionCreateNestedOneWithoutHistoryInput
    user: UserProfileCreateNestedOneWithoutSessionHistoryInput
    game: GameCreateNestedOneWithoutSessionHistoryInput
  }

  export type SessionHistoryUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId: string
    gameId: string
    role: $Enums.ParticipantRole
    startedAt: Date | string
    endedAt: Date | string
    durationMinutes: number
    totalPlayers?: number
  }

  export type SessionHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    totalPlayers?: IntFieldUpdateOperationsInput | number
    session?: GameSessionUpdateOneRequiredWithoutHistoryNestedInput
    user?: UserProfileUpdateOneRequiredWithoutSessionHistoryNestedInput
    game?: GameUpdateOneRequiredWithoutSessionHistoryNestedInput
  }

  export type SessionHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    totalPlayers?: IntFieldUpdateOperationsInput | number
  }

  export type SessionHistoryCreateManyInput = {
    id?: string
    sessionId: string
    userId: string
    gameId: string
    role: $Enums.ParticipantRole
    startedAt: Date | string
    endedAt: Date | string
    durationMinutes: number
    totalPlayers?: number
  }

  export type SessionHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    totalPlayers?: IntFieldUpdateOperationsInput | number
  }

  export type SessionHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    totalPlayers?: IntFieldUpdateOperationsInput | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type GameSessionListRelationFilter = {
    every?: GameSessionWhereInput
    some?: GameSessionWhereInput
    none?: GameSessionWhereInput
  }

  export type UserGameLibraryListRelationFilter = {
    every?: UserGameLibraryWhereInput
    some?: UserGameLibraryWhereInput
    none?: UserGameLibraryWhereInput
  }

  export type SessionParticipantListRelationFilter = {
    every?: SessionParticipantWhereInput
    some?: SessionParticipantWhereInput
    none?: SessionParticipantWhereInput
  }

  export type SessionChatListRelationFilter = {
    every?: SessionChatWhereInput
    some?: SessionChatWhereInput
    none?: SessionChatWhereInput
  }

  export type SessionHistoryListRelationFilter = {
    every?: SessionHistoryWhereInput
    some?: SessionHistoryWhereInput
    none?: SessionHistoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type GameSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserGameLibraryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    platiumUserId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    preferredEmulator?: SortOrder
    isOnline?: SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    platiumUserId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    preferredEmulator?: SortOrder
    isOnline?: SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    platiumUserId?: SortOrder
    username?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    preferredEmulator?: SortOrder
    isOnline?: SortOrder
    lastSeenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    system?: SortOrder
    year?: SortOrder
    genre?: SortOrder
    playerCount?: SortOrder
    romPath?: SortOrder
    emulator?: SortOrder
    emulatorCore?: SortOrder
    coverArtUrl?: SortOrder
    screenshotUrls?: SortOrder
    description?: SortOrder
    rating?: SortOrder
    playCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    year?: SortOrder
    playerCount?: SortOrder
    rating?: SortOrder
    playCount?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    system?: SortOrder
    year?: SortOrder
    genre?: SortOrder
    playerCount?: SortOrder
    romPath?: SortOrder
    emulator?: SortOrder
    emulatorCore?: SortOrder
    coverArtUrl?: SortOrder
    description?: SortOrder
    rating?: SortOrder
    playCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    system?: SortOrder
    year?: SortOrder
    genre?: SortOrder
    playerCount?: SortOrder
    romPath?: SortOrder
    emulator?: SortOrder
    emulatorCore?: SortOrder
    coverArtUrl?: SortOrder
    description?: SortOrder
    rating?: SortOrder
    playCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    year?: SortOrder
    playerCount?: SortOrder
    rating?: SortOrder
    playCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type EnumSessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypeFilter<$PrismaModel> | $Enums.SessionType
  }

  export type EnumVideoQualityFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoQuality | EnumVideoQualityFieldRefInput<$PrismaModel>
    in?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoQualityFilter<$PrismaModel> | $Enums.VideoQuality
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type GameRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type UserProfileRelationFilter = {
    is?: UserProfileWhereInput
    isNot?: UserProfileWhereInput
  }

  export type GameSessionCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    createdBy?: SortOrder
    sessionCode?: SortOrder
    status?: SortOrder
    sessionType?: SortOrder
    isPrivate?: SortOrder
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
    spectatorCount?: SortOrder
    containerId?: SortOrder
    containerIp?: SortOrder
    containerPort?: SortOrder
    videoQuality?: SortOrder
    fps?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    lastActivityAt?: SortOrder
    durationMinutes?: SortOrder
  }

  export type GameSessionAvgOrderByAggregateInput = {
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
    spectatorCount?: SortOrder
    containerPort?: SortOrder
    fps?: SortOrder
    durationMinutes?: SortOrder
  }

  export type GameSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    createdBy?: SortOrder
    sessionCode?: SortOrder
    status?: SortOrder
    sessionType?: SortOrder
    isPrivate?: SortOrder
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
    spectatorCount?: SortOrder
    containerId?: SortOrder
    containerIp?: SortOrder
    containerPort?: SortOrder
    videoQuality?: SortOrder
    fps?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    lastActivityAt?: SortOrder
    durationMinutes?: SortOrder
  }

  export type GameSessionMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    createdBy?: SortOrder
    sessionCode?: SortOrder
    status?: SortOrder
    sessionType?: SortOrder
    isPrivate?: SortOrder
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
    spectatorCount?: SortOrder
    containerId?: SortOrder
    containerIp?: SortOrder
    containerPort?: SortOrder
    videoQuality?: SortOrder
    fps?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    lastActivityAt?: SortOrder
    durationMinutes?: SortOrder
  }

  export type GameSessionSumOrderByAggregateInput = {
    maxPlayers?: SortOrder
    currentPlayers?: SortOrder
    spectatorCount?: SortOrder
    containerPort?: SortOrder
    fps?: SortOrder
    durationMinutes?: SortOrder
  }

  export type EnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type EnumSessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionTypeFilter<$PrismaModel>
    _max?: NestedEnumSessionTypeFilter<$PrismaModel>
  }

  export type EnumVideoQualityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoQuality | EnumVideoQualityFieldRefInput<$PrismaModel>
    in?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoQualityWithAggregatesFilter<$PrismaModel> | $Enums.VideoQuality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoQualityFilter<$PrismaModel>
    _max?: NestedEnumVideoQualityFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumParticipantRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantRole | EnumParticipantRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantRole[] | ListEnumParticipantRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantRole[] | ListEnumParticipantRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantRoleFilter<$PrismaModel> | $Enums.ParticipantRole
  }

  export type GameSessionRelationFilter = {
    is?: GameSessionWhereInput
    isNot?: GameSessionWhereInput
  }

  export type SessionParticipantSessionIdUserIdCompoundUniqueInput = {
    sessionId: string
    userId: string
  }

  export type SessionParticipantCountOrderByAggregateInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isHost?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    totalDurationMinutes?: SortOrder
  }

  export type SessionParticipantAvgOrderByAggregateInput = {
    totalDurationMinutes?: SortOrder
  }

  export type SessionParticipantMaxOrderByAggregateInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isHost?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    totalDurationMinutes?: SortOrder
  }

  export type SessionParticipantMinOrderByAggregateInput = {
    sessionId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isHost?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    totalDurationMinutes?: SortOrder
  }

  export type SessionParticipantSumOrderByAggregateInput = {
    totalDurationMinutes?: SortOrder
  }

  export type EnumParticipantRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantRole | EnumParticipantRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantRole[] | ListEnumParticipantRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantRole[] | ListEnumParticipantRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantRoleWithAggregatesFilter<$PrismaModel> | $Enums.ParticipantRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParticipantRoleFilter<$PrismaModel>
    _max?: NestedEnumParticipantRoleFilter<$PrismaModel>
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type SessionChatCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionChatMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionChatMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type EnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus
  }

  export type UserGameLibraryUserIdGameIdCompoundUniqueInput = {
    userId: string
    gameId: string
  }

  export type UserGameLibraryCountOrderByAggregateInput = {
    userId?: SortOrder
    gameId?: SortOrder
    status?: SortOrder
    playTimeMinutes?: SortOrder
    lastPlayedAt?: SortOrder
    rating?: SortOrder
    addedAt?: SortOrder
  }

  export type UserGameLibraryAvgOrderByAggregateInput = {
    playTimeMinutes?: SortOrder
    rating?: SortOrder
  }

  export type UserGameLibraryMaxOrderByAggregateInput = {
    userId?: SortOrder
    gameId?: SortOrder
    status?: SortOrder
    playTimeMinutes?: SortOrder
    lastPlayedAt?: SortOrder
    rating?: SortOrder
    addedAt?: SortOrder
  }

  export type UserGameLibraryMinOrderByAggregateInput = {
    userId?: SortOrder
    gameId?: SortOrder
    status?: SortOrder
    playTimeMinutes?: SortOrder
    lastPlayedAt?: SortOrder
    rating?: SortOrder
    addedAt?: SortOrder
  }

  export type UserGameLibrarySumOrderByAggregateInput = {
    playTimeMinutes?: SortOrder
    rating?: SortOrder
  }

  export type EnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusFilter<$PrismaModel>
    _max?: NestedEnumGameStatusFilter<$PrismaModel>
  }

  export type SessionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    role?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    durationMinutes?: SortOrder
    totalPlayers?: SortOrder
  }

  export type SessionHistoryAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
    totalPlayers?: SortOrder
  }

  export type SessionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    role?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    durationMinutes?: SortOrder
    totalPlayers?: SortOrder
  }

  export type SessionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    gameId?: SortOrder
    role?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    durationMinutes?: SortOrder
    totalPlayers?: SortOrder
  }

  export type SessionHistorySumOrderByAggregateInput = {
    durationMinutes?: SortOrder
    totalPlayers?: SortOrder
  }

  export type GameSessionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GameSessionCreateWithoutCreatorInput, GameSessionUncheckedCreateWithoutCreatorInput> | GameSessionCreateWithoutCreatorInput[] | GameSessionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutCreatorInput | GameSessionCreateOrConnectWithoutCreatorInput[]
    createMany?: GameSessionCreateManyCreatorInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type UserGameLibraryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserGameLibraryCreateWithoutUserInput, UserGameLibraryUncheckedCreateWithoutUserInput> | UserGameLibraryCreateWithoutUserInput[] | UserGameLibraryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGameLibraryCreateOrConnectWithoutUserInput | UserGameLibraryCreateOrConnectWithoutUserInput[]
    createMany?: UserGameLibraryCreateManyUserInputEnvelope
    connect?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
  }

  export type SessionParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionParticipantCreateWithoutUserInput, SessionParticipantUncheckedCreateWithoutUserInput> | SessionParticipantCreateWithoutUserInput[] | SessionParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionParticipantCreateOrConnectWithoutUserInput | SessionParticipantCreateOrConnectWithoutUserInput[]
    createMany?: SessionParticipantCreateManyUserInputEnvelope
    connect?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
  }

  export type SessionChatCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionChatCreateWithoutUserInput, SessionChatUncheckedCreateWithoutUserInput> | SessionChatCreateWithoutUserInput[] | SessionChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionChatCreateOrConnectWithoutUserInput | SessionChatCreateOrConnectWithoutUserInput[]
    createMany?: SessionChatCreateManyUserInputEnvelope
    connect?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
  }

  export type SessionHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionHistoryCreateWithoutUserInput, SessionHistoryUncheckedCreateWithoutUserInput> | SessionHistoryCreateWithoutUserInput[] | SessionHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutUserInput | SessionHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SessionHistoryCreateManyUserInputEnvelope
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
  }

  export type GameSessionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<GameSessionCreateWithoutCreatorInput, GameSessionUncheckedCreateWithoutCreatorInput> | GameSessionCreateWithoutCreatorInput[] | GameSessionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutCreatorInput | GameSessionCreateOrConnectWithoutCreatorInput[]
    createMany?: GameSessionCreateManyCreatorInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type UserGameLibraryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserGameLibraryCreateWithoutUserInput, UserGameLibraryUncheckedCreateWithoutUserInput> | UserGameLibraryCreateWithoutUserInput[] | UserGameLibraryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGameLibraryCreateOrConnectWithoutUserInput | UserGameLibraryCreateOrConnectWithoutUserInput[]
    createMany?: UserGameLibraryCreateManyUserInputEnvelope
    connect?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
  }

  export type SessionParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionParticipantCreateWithoutUserInput, SessionParticipantUncheckedCreateWithoutUserInput> | SessionParticipantCreateWithoutUserInput[] | SessionParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionParticipantCreateOrConnectWithoutUserInput | SessionParticipantCreateOrConnectWithoutUserInput[]
    createMany?: SessionParticipantCreateManyUserInputEnvelope
    connect?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
  }

  export type SessionChatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionChatCreateWithoutUserInput, SessionChatUncheckedCreateWithoutUserInput> | SessionChatCreateWithoutUserInput[] | SessionChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionChatCreateOrConnectWithoutUserInput | SessionChatCreateOrConnectWithoutUserInput[]
    createMany?: SessionChatCreateManyUserInputEnvelope
    connect?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
  }

  export type SessionHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionHistoryCreateWithoutUserInput, SessionHistoryUncheckedCreateWithoutUserInput> | SessionHistoryCreateWithoutUserInput[] | SessionHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutUserInput | SessionHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SessionHistoryCreateManyUserInputEnvelope
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type GameSessionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GameSessionCreateWithoutCreatorInput, GameSessionUncheckedCreateWithoutCreatorInput> | GameSessionCreateWithoutCreatorInput[] | GameSessionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutCreatorInput | GameSessionCreateOrConnectWithoutCreatorInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutCreatorInput | GameSessionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GameSessionCreateManyCreatorInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutCreatorInput | GameSessionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutCreatorInput | GameSessionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type UserGameLibraryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserGameLibraryCreateWithoutUserInput, UserGameLibraryUncheckedCreateWithoutUserInput> | UserGameLibraryCreateWithoutUserInput[] | UserGameLibraryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGameLibraryCreateOrConnectWithoutUserInput | UserGameLibraryCreateOrConnectWithoutUserInput[]
    upsert?: UserGameLibraryUpsertWithWhereUniqueWithoutUserInput | UserGameLibraryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserGameLibraryCreateManyUserInputEnvelope
    set?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    disconnect?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    delete?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    connect?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    update?: UserGameLibraryUpdateWithWhereUniqueWithoutUserInput | UserGameLibraryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserGameLibraryUpdateManyWithWhereWithoutUserInput | UserGameLibraryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserGameLibraryScalarWhereInput | UserGameLibraryScalarWhereInput[]
  }

  export type SessionParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionParticipantCreateWithoutUserInput, SessionParticipantUncheckedCreateWithoutUserInput> | SessionParticipantCreateWithoutUserInput[] | SessionParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionParticipantCreateOrConnectWithoutUserInput | SessionParticipantCreateOrConnectWithoutUserInput[]
    upsert?: SessionParticipantUpsertWithWhereUniqueWithoutUserInput | SessionParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionParticipantCreateManyUserInputEnvelope
    set?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    disconnect?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    delete?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    connect?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    update?: SessionParticipantUpdateWithWhereUniqueWithoutUserInput | SessionParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionParticipantUpdateManyWithWhereWithoutUserInput | SessionParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionParticipantScalarWhereInput | SessionParticipantScalarWhereInput[]
  }

  export type SessionChatUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionChatCreateWithoutUserInput, SessionChatUncheckedCreateWithoutUserInput> | SessionChatCreateWithoutUserInput[] | SessionChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionChatCreateOrConnectWithoutUserInput | SessionChatCreateOrConnectWithoutUserInput[]
    upsert?: SessionChatUpsertWithWhereUniqueWithoutUserInput | SessionChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionChatCreateManyUserInputEnvelope
    set?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    disconnect?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    delete?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    connect?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    update?: SessionChatUpdateWithWhereUniqueWithoutUserInput | SessionChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionChatUpdateManyWithWhereWithoutUserInput | SessionChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionChatScalarWhereInput | SessionChatScalarWhereInput[]
  }

  export type SessionHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionHistoryCreateWithoutUserInput, SessionHistoryUncheckedCreateWithoutUserInput> | SessionHistoryCreateWithoutUserInput[] | SessionHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutUserInput | SessionHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SessionHistoryUpsertWithWhereUniqueWithoutUserInput | SessionHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionHistoryCreateManyUserInputEnvelope
    set?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    disconnect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    delete?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    update?: SessionHistoryUpdateWithWhereUniqueWithoutUserInput | SessionHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionHistoryUpdateManyWithWhereWithoutUserInput | SessionHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionHistoryScalarWhereInput | SessionHistoryScalarWhereInput[]
  }

  export type GameSessionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<GameSessionCreateWithoutCreatorInput, GameSessionUncheckedCreateWithoutCreatorInput> | GameSessionCreateWithoutCreatorInput[] | GameSessionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutCreatorInput | GameSessionCreateOrConnectWithoutCreatorInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutCreatorInput | GameSessionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: GameSessionCreateManyCreatorInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutCreatorInput | GameSessionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutCreatorInput | GameSessionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type UserGameLibraryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserGameLibraryCreateWithoutUserInput, UserGameLibraryUncheckedCreateWithoutUserInput> | UserGameLibraryCreateWithoutUserInput[] | UserGameLibraryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGameLibraryCreateOrConnectWithoutUserInput | UserGameLibraryCreateOrConnectWithoutUserInput[]
    upsert?: UserGameLibraryUpsertWithWhereUniqueWithoutUserInput | UserGameLibraryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserGameLibraryCreateManyUserInputEnvelope
    set?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    disconnect?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    delete?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    connect?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    update?: UserGameLibraryUpdateWithWhereUniqueWithoutUserInput | UserGameLibraryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserGameLibraryUpdateManyWithWhereWithoutUserInput | UserGameLibraryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserGameLibraryScalarWhereInput | UserGameLibraryScalarWhereInput[]
  }

  export type SessionParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionParticipantCreateWithoutUserInput, SessionParticipantUncheckedCreateWithoutUserInput> | SessionParticipantCreateWithoutUserInput[] | SessionParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionParticipantCreateOrConnectWithoutUserInput | SessionParticipantCreateOrConnectWithoutUserInput[]
    upsert?: SessionParticipantUpsertWithWhereUniqueWithoutUserInput | SessionParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionParticipantCreateManyUserInputEnvelope
    set?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    disconnect?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    delete?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    connect?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    update?: SessionParticipantUpdateWithWhereUniqueWithoutUserInput | SessionParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionParticipantUpdateManyWithWhereWithoutUserInput | SessionParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionParticipantScalarWhereInput | SessionParticipantScalarWhereInput[]
  }

  export type SessionChatUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionChatCreateWithoutUserInput, SessionChatUncheckedCreateWithoutUserInput> | SessionChatCreateWithoutUserInput[] | SessionChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionChatCreateOrConnectWithoutUserInput | SessionChatCreateOrConnectWithoutUserInput[]
    upsert?: SessionChatUpsertWithWhereUniqueWithoutUserInput | SessionChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionChatCreateManyUserInputEnvelope
    set?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    disconnect?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    delete?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    connect?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    update?: SessionChatUpdateWithWhereUniqueWithoutUserInput | SessionChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionChatUpdateManyWithWhereWithoutUserInput | SessionChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionChatScalarWhereInput | SessionChatScalarWhereInput[]
  }

  export type SessionHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionHistoryCreateWithoutUserInput, SessionHistoryUncheckedCreateWithoutUserInput> | SessionHistoryCreateWithoutUserInput[] | SessionHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutUserInput | SessionHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SessionHistoryUpsertWithWhereUniqueWithoutUserInput | SessionHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionHistoryCreateManyUserInputEnvelope
    set?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    disconnect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    delete?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    update?: SessionHistoryUpdateWithWhereUniqueWithoutUserInput | SessionHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionHistoryUpdateManyWithWhereWithoutUserInput | SessionHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionHistoryScalarWhereInput | SessionHistoryScalarWhereInput[]
  }

  export type GameCreatescreenshotUrlsInput = {
    set: string[]
  }

  export type GameSessionCreateNestedManyWithoutGameInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type UserGameLibraryCreateNestedManyWithoutGameInput = {
    create?: XOR<UserGameLibraryCreateWithoutGameInput, UserGameLibraryUncheckedCreateWithoutGameInput> | UserGameLibraryCreateWithoutGameInput[] | UserGameLibraryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: UserGameLibraryCreateOrConnectWithoutGameInput | UserGameLibraryCreateOrConnectWithoutGameInput[]
    createMany?: UserGameLibraryCreateManyGameInputEnvelope
    connect?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
  }

  export type SessionHistoryCreateNestedManyWithoutGameInput = {
    create?: XOR<SessionHistoryCreateWithoutGameInput, SessionHistoryUncheckedCreateWithoutGameInput> | SessionHistoryCreateWithoutGameInput[] | SessionHistoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutGameInput | SessionHistoryCreateOrConnectWithoutGameInput[]
    createMany?: SessionHistoryCreateManyGameInputEnvelope
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
  }

  export type GameSessionUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
  }

  export type UserGameLibraryUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<UserGameLibraryCreateWithoutGameInput, UserGameLibraryUncheckedCreateWithoutGameInput> | UserGameLibraryCreateWithoutGameInput[] | UserGameLibraryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: UserGameLibraryCreateOrConnectWithoutGameInput | UserGameLibraryCreateOrConnectWithoutGameInput[]
    createMany?: UserGameLibraryCreateManyGameInputEnvelope
    connect?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
  }

  export type SessionHistoryUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<SessionHistoryCreateWithoutGameInput, SessionHistoryUncheckedCreateWithoutGameInput> | SessionHistoryCreateWithoutGameInput[] | SessionHistoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutGameInput | SessionHistoryCreateOrConnectWithoutGameInput[]
    createMany?: SessionHistoryCreateManyGameInputEnvelope
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type GameUpdatescreenshotUrlsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type GameSessionUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutGameInput | GameSessionUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutGameInput | GameSessionUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutGameInput | GameSessionUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type UserGameLibraryUpdateManyWithoutGameNestedInput = {
    create?: XOR<UserGameLibraryCreateWithoutGameInput, UserGameLibraryUncheckedCreateWithoutGameInput> | UserGameLibraryCreateWithoutGameInput[] | UserGameLibraryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: UserGameLibraryCreateOrConnectWithoutGameInput | UserGameLibraryCreateOrConnectWithoutGameInput[]
    upsert?: UserGameLibraryUpsertWithWhereUniqueWithoutGameInput | UserGameLibraryUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: UserGameLibraryCreateManyGameInputEnvelope
    set?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    disconnect?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    delete?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    connect?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    update?: UserGameLibraryUpdateWithWhereUniqueWithoutGameInput | UserGameLibraryUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: UserGameLibraryUpdateManyWithWhereWithoutGameInput | UserGameLibraryUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: UserGameLibraryScalarWhereInput | UserGameLibraryScalarWhereInput[]
  }

  export type SessionHistoryUpdateManyWithoutGameNestedInput = {
    create?: XOR<SessionHistoryCreateWithoutGameInput, SessionHistoryUncheckedCreateWithoutGameInput> | SessionHistoryCreateWithoutGameInput[] | SessionHistoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutGameInput | SessionHistoryCreateOrConnectWithoutGameInput[]
    upsert?: SessionHistoryUpsertWithWhereUniqueWithoutGameInput | SessionHistoryUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: SessionHistoryCreateManyGameInputEnvelope
    set?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    disconnect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    delete?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    update?: SessionHistoryUpdateWithWhereUniqueWithoutGameInput | SessionHistoryUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: SessionHistoryUpdateManyWithWhereWithoutGameInput | SessionHistoryUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: SessionHistoryScalarWhereInput | SessionHistoryScalarWhereInput[]
  }

  export type GameSessionUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput> | GameSessionCreateWithoutGameInput[] | GameSessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameSessionCreateOrConnectWithoutGameInput | GameSessionCreateOrConnectWithoutGameInput[]
    upsert?: GameSessionUpsertWithWhereUniqueWithoutGameInput | GameSessionUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameSessionCreateManyGameInputEnvelope
    set?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    disconnect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    delete?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    connect?: GameSessionWhereUniqueInput | GameSessionWhereUniqueInput[]
    update?: GameSessionUpdateWithWhereUniqueWithoutGameInput | GameSessionUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameSessionUpdateManyWithWhereWithoutGameInput | GameSessionUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
  }

  export type UserGameLibraryUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<UserGameLibraryCreateWithoutGameInput, UserGameLibraryUncheckedCreateWithoutGameInput> | UserGameLibraryCreateWithoutGameInput[] | UserGameLibraryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: UserGameLibraryCreateOrConnectWithoutGameInput | UserGameLibraryCreateOrConnectWithoutGameInput[]
    upsert?: UserGameLibraryUpsertWithWhereUniqueWithoutGameInput | UserGameLibraryUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: UserGameLibraryCreateManyGameInputEnvelope
    set?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    disconnect?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    delete?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    connect?: UserGameLibraryWhereUniqueInput | UserGameLibraryWhereUniqueInput[]
    update?: UserGameLibraryUpdateWithWhereUniqueWithoutGameInput | UserGameLibraryUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: UserGameLibraryUpdateManyWithWhereWithoutGameInput | UserGameLibraryUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: UserGameLibraryScalarWhereInput | UserGameLibraryScalarWhereInput[]
  }

  export type SessionHistoryUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<SessionHistoryCreateWithoutGameInput, SessionHistoryUncheckedCreateWithoutGameInput> | SessionHistoryCreateWithoutGameInput[] | SessionHistoryUncheckedCreateWithoutGameInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutGameInput | SessionHistoryCreateOrConnectWithoutGameInput[]
    upsert?: SessionHistoryUpsertWithWhereUniqueWithoutGameInput | SessionHistoryUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: SessionHistoryCreateManyGameInputEnvelope
    set?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    disconnect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    delete?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    update?: SessionHistoryUpdateWithWhereUniqueWithoutGameInput | SessionHistoryUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: SessionHistoryUpdateManyWithWhereWithoutGameInput | SessionHistoryUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: SessionHistoryScalarWhereInput | SessionHistoryScalarWhereInput[]
  }

  export type GameCreateNestedOneWithoutSessionsInput = {
    create?: XOR<GameCreateWithoutSessionsInput, GameUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: GameCreateOrConnectWithoutSessionsInput
    connect?: GameWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutCreatedSessionsInput = {
    create?: XOR<UserProfileCreateWithoutCreatedSessionsInput, UserProfileUncheckedCreateWithoutCreatedSessionsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutCreatedSessionsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type SessionParticipantCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionParticipantCreateWithoutSessionInput, SessionParticipantUncheckedCreateWithoutSessionInput> | SessionParticipantCreateWithoutSessionInput[] | SessionParticipantUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionParticipantCreateOrConnectWithoutSessionInput | SessionParticipantCreateOrConnectWithoutSessionInput[]
    createMany?: SessionParticipantCreateManySessionInputEnvelope
    connect?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
  }

  export type SessionChatCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionChatCreateWithoutSessionInput, SessionChatUncheckedCreateWithoutSessionInput> | SessionChatCreateWithoutSessionInput[] | SessionChatUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionChatCreateOrConnectWithoutSessionInput | SessionChatCreateOrConnectWithoutSessionInput[]
    createMany?: SessionChatCreateManySessionInputEnvelope
    connect?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
  }

  export type SessionHistoryCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionHistoryCreateWithoutSessionInput, SessionHistoryUncheckedCreateWithoutSessionInput> | SessionHistoryCreateWithoutSessionInput[] | SessionHistoryUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutSessionInput | SessionHistoryCreateOrConnectWithoutSessionInput[]
    createMany?: SessionHistoryCreateManySessionInputEnvelope
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
  }

  export type SessionParticipantUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionParticipantCreateWithoutSessionInput, SessionParticipantUncheckedCreateWithoutSessionInput> | SessionParticipantCreateWithoutSessionInput[] | SessionParticipantUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionParticipantCreateOrConnectWithoutSessionInput | SessionParticipantCreateOrConnectWithoutSessionInput[]
    createMany?: SessionParticipantCreateManySessionInputEnvelope
    connect?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
  }

  export type SessionChatUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionChatCreateWithoutSessionInput, SessionChatUncheckedCreateWithoutSessionInput> | SessionChatCreateWithoutSessionInput[] | SessionChatUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionChatCreateOrConnectWithoutSessionInput | SessionChatCreateOrConnectWithoutSessionInput[]
    createMany?: SessionChatCreateManySessionInputEnvelope
    connect?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
  }

  export type SessionHistoryUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionHistoryCreateWithoutSessionInput, SessionHistoryUncheckedCreateWithoutSessionInput> | SessionHistoryCreateWithoutSessionInput[] | SessionHistoryUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutSessionInput | SessionHistoryCreateOrConnectWithoutSessionInput[]
    createMany?: SessionHistoryCreateManySessionInputEnvelope
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
  }

  export type EnumSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SessionStatus
  }

  export type EnumSessionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SessionType
  }

  export type EnumVideoQualityFieldUpdateOperationsInput = {
    set?: $Enums.VideoQuality
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type GameUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<GameCreateWithoutSessionsInput, GameUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: GameCreateOrConnectWithoutSessionsInput
    upsert?: GameUpsertWithoutSessionsInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutSessionsInput, GameUpdateWithoutSessionsInput>, GameUncheckedUpdateWithoutSessionsInput>
  }

  export type UserProfileUpdateOneRequiredWithoutCreatedSessionsNestedInput = {
    create?: XOR<UserProfileCreateWithoutCreatedSessionsInput, UserProfileUncheckedCreateWithoutCreatedSessionsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutCreatedSessionsInput
    upsert?: UserProfileUpsertWithoutCreatedSessionsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutCreatedSessionsInput, UserProfileUpdateWithoutCreatedSessionsInput>, UserProfileUncheckedUpdateWithoutCreatedSessionsInput>
  }

  export type SessionParticipantUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionParticipantCreateWithoutSessionInput, SessionParticipantUncheckedCreateWithoutSessionInput> | SessionParticipantCreateWithoutSessionInput[] | SessionParticipantUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionParticipantCreateOrConnectWithoutSessionInput | SessionParticipantCreateOrConnectWithoutSessionInput[]
    upsert?: SessionParticipantUpsertWithWhereUniqueWithoutSessionInput | SessionParticipantUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionParticipantCreateManySessionInputEnvelope
    set?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    disconnect?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    delete?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    connect?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    update?: SessionParticipantUpdateWithWhereUniqueWithoutSessionInput | SessionParticipantUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionParticipantUpdateManyWithWhereWithoutSessionInput | SessionParticipantUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionParticipantScalarWhereInput | SessionParticipantScalarWhereInput[]
  }

  export type SessionChatUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionChatCreateWithoutSessionInput, SessionChatUncheckedCreateWithoutSessionInput> | SessionChatCreateWithoutSessionInput[] | SessionChatUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionChatCreateOrConnectWithoutSessionInput | SessionChatCreateOrConnectWithoutSessionInput[]
    upsert?: SessionChatUpsertWithWhereUniqueWithoutSessionInput | SessionChatUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionChatCreateManySessionInputEnvelope
    set?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    disconnect?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    delete?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    connect?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    update?: SessionChatUpdateWithWhereUniqueWithoutSessionInput | SessionChatUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionChatUpdateManyWithWhereWithoutSessionInput | SessionChatUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionChatScalarWhereInput | SessionChatScalarWhereInput[]
  }

  export type SessionHistoryUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionHistoryCreateWithoutSessionInput, SessionHistoryUncheckedCreateWithoutSessionInput> | SessionHistoryCreateWithoutSessionInput[] | SessionHistoryUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutSessionInput | SessionHistoryCreateOrConnectWithoutSessionInput[]
    upsert?: SessionHistoryUpsertWithWhereUniqueWithoutSessionInput | SessionHistoryUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionHistoryCreateManySessionInputEnvelope
    set?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    disconnect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    delete?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    update?: SessionHistoryUpdateWithWhereUniqueWithoutSessionInput | SessionHistoryUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionHistoryUpdateManyWithWhereWithoutSessionInput | SessionHistoryUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionHistoryScalarWhereInput | SessionHistoryScalarWhereInput[]
  }

  export type SessionParticipantUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionParticipantCreateWithoutSessionInput, SessionParticipantUncheckedCreateWithoutSessionInput> | SessionParticipantCreateWithoutSessionInput[] | SessionParticipantUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionParticipantCreateOrConnectWithoutSessionInput | SessionParticipantCreateOrConnectWithoutSessionInput[]
    upsert?: SessionParticipantUpsertWithWhereUniqueWithoutSessionInput | SessionParticipantUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionParticipantCreateManySessionInputEnvelope
    set?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    disconnect?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    delete?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    connect?: SessionParticipantWhereUniqueInput | SessionParticipantWhereUniqueInput[]
    update?: SessionParticipantUpdateWithWhereUniqueWithoutSessionInput | SessionParticipantUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionParticipantUpdateManyWithWhereWithoutSessionInput | SessionParticipantUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionParticipantScalarWhereInput | SessionParticipantScalarWhereInput[]
  }

  export type SessionChatUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionChatCreateWithoutSessionInput, SessionChatUncheckedCreateWithoutSessionInput> | SessionChatCreateWithoutSessionInput[] | SessionChatUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionChatCreateOrConnectWithoutSessionInput | SessionChatCreateOrConnectWithoutSessionInput[]
    upsert?: SessionChatUpsertWithWhereUniqueWithoutSessionInput | SessionChatUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionChatCreateManySessionInputEnvelope
    set?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    disconnect?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    delete?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    connect?: SessionChatWhereUniqueInput | SessionChatWhereUniqueInput[]
    update?: SessionChatUpdateWithWhereUniqueWithoutSessionInput | SessionChatUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionChatUpdateManyWithWhereWithoutSessionInput | SessionChatUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionChatScalarWhereInput | SessionChatScalarWhereInput[]
  }

  export type SessionHistoryUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionHistoryCreateWithoutSessionInput, SessionHistoryUncheckedCreateWithoutSessionInput> | SessionHistoryCreateWithoutSessionInput[] | SessionHistoryUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutSessionInput | SessionHistoryCreateOrConnectWithoutSessionInput[]
    upsert?: SessionHistoryUpsertWithWhereUniqueWithoutSessionInput | SessionHistoryUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionHistoryCreateManySessionInputEnvelope
    set?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    disconnect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    delete?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    update?: SessionHistoryUpdateWithWhereUniqueWithoutSessionInput | SessionHistoryUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionHistoryUpdateManyWithWhereWithoutSessionInput | SessionHistoryUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionHistoryScalarWhereInput | SessionHistoryScalarWhereInput[]
  }

  export type GameSessionCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<GameSessionCreateWithoutParticipantsInput, GameSessionUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: GameSessionCreateOrConnectWithoutParticipantsInput
    connect?: GameSessionWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutParticipationsInput = {
    create?: XOR<UserProfileCreateWithoutParticipationsInput, UserProfileUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutParticipationsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type EnumParticipantRoleFieldUpdateOperationsInput = {
    set?: $Enums.ParticipantRole
  }

  export type GameSessionUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<GameSessionCreateWithoutParticipantsInput, GameSessionUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: GameSessionCreateOrConnectWithoutParticipantsInput
    upsert?: GameSessionUpsertWithoutParticipantsInput
    connect?: GameSessionWhereUniqueInput
    update?: XOR<XOR<GameSessionUpdateToOneWithWhereWithoutParticipantsInput, GameSessionUpdateWithoutParticipantsInput>, GameSessionUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserProfileUpdateOneRequiredWithoutParticipationsNestedInput = {
    create?: XOR<UserProfileCreateWithoutParticipationsInput, UserProfileUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutParticipationsInput
    upsert?: UserProfileUpsertWithoutParticipationsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutParticipationsInput, UserProfileUpdateWithoutParticipationsInput>, UserProfileUncheckedUpdateWithoutParticipationsInput>
  }

  export type GameSessionCreateNestedOneWithoutChatMessagesInput = {
    create?: XOR<GameSessionCreateWithoutChatMessagesInput, GameSessionUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: GameSessionCreateOrConnectWithoutChatMessagesInput
    connect?: GameSessionWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutChatMessagesInput = {
    create?: XOR<UserProfileCreateWithoutChatMessagesInput, UserProfileUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutChatMessagesInput
    connect?: UserProfileWhereUniqueInput
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type GameSessionUpdateOneRequiredWithoutChatMessagesNestedInput = {
    create?: XOR<GameSessionCreateWithoutChatMessagesInput, GameSessionUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: GameSessionCreateOrConnectWithoutChatMessagesInput
    upsert?: GameSessionUpsertWithoutChatMessagesInput
    connect?: GameSessionWhereUniqueInput
    update?: XOR<XOR<GameSessionUpdateToOneWithWhereWithoutChatMessagesInput, GameSessionUpdateWithoutChatMessagesInput>, GameSessionUncheckedUpdateWithoutChatMessagesInput>
  }

  export type UserProfileUpdateOneRequiredWithoutChatMessagesNestedInput = {
    create?: XOR<UserProfileCreateWithoutChatMessagesInput, UserProfileUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutChatMessagesInput
    upsert?: UserProfileUpsertWithoutChatMessagesInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutChatMessagesInput, UserProfileUpdateWithoutChatMessagesInput>, UserProfileUncheckedUpdateWithoutChatMessagesInput>
  }

  export type UserProfileCreateNestedOneWithoutLibraryInput = {
    create?: XOR<UserProfileCreateWithoutLibraryInput, UserProfileUncheckedCreateWithoutLibraryInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutLibraryInput
    connect?: UserProfileWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutLibraryEntriesInput = {
    create?: XOR<GameCreateWithoutLibraryEntriesInput, GameUncheckedCreateWithoutLibraryEntriesInput>
    connectOrCreate?: GameCreateOrConnectWithoutLibraryEntriesInput
    connect?: GameWhereUniqueInput
  }

  export type EnumGameStatusFieldUpdateOperationsInput = {
    set?: $Enums.GameStatus
  }

  export type UserProfileUpdateOneRequiredWithoutLibraryNestedInput = {
    create?: XOR<UserProfileCreateWithoutLibraryInput, UserProfileUncheckedCreateWithoutLibraryInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutLibraryInput
    upsert?: UserProfileUpsertWithoutLibraryInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutLibraryInput, UserProfileUpdateWithoutLibraryInput>, UserProfileUncheckedUpdateWithoutLibraryInput>
  }

  export type GameUpdateOneRequiredWithoutLibraryEntriesNestedInput = {
    create?: XOR<GameCreateWithoutLibraryEntriesInput, GameUncheckedCreateWithoutLibraryEntriesInput>
    connectOrCreate?: GameCreateOrConnectWithoutLibraryEntriesInput
    upsert?: GameUpsertWithoutLibraryEntriesInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutLibraryEntriesInput, GameUpdateWithoutLibraryEntriesInput>, GameUncheckedUpdateWithoutLibraryEntriesInput>
  }

  export type GameSessionCreateNestedOneWithoutHistoryInput = {
    create?: XOR<GameSessionCreateWithoutHistoryInput, GameSessionUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: GameSessionCreateOrConnectWithoutHistoryInput
    connect?: GameSessionWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutSessionHistoryInput = {
    create?: XOR<UserProfileCreateWithoutSessionHistoryInput, UserProfileUncheckedCreateWithoutSessionHistoryInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutSessionHistoryInput
    connect?: UserProfileWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutSessionHistoryInput = {
    create?: XOR<GameCreateWithoutSessionHistoryInput, GameUncheckedCreateWithoutSessionHistoryInput>
    connectOrCreate?: GameCreateOrConnectWithoutSessionHistoryInput
    connect?: GameWhereUniqueInput
  }

  export type GameSessionUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<GameSessionCreateWithoutHistoryInput, GameSessionUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: GameSessionCreateOrConnectWithoutHistoryInput
    upsert?: GameSessionUpsertWithoutHistoryInput
    connect?: GameSessionWhereUniqueInput
    update?: XOR<XOR<GameSessionUpdateToOneWithWhereWithoutHistoryInput, GameSessionUpdateWithoutHistoryInput>, GameSessionUncheckedUpdateWithoutHistoryInput>
  }

  export type UserProfileUpdateOneRequiredWithoutSessionHistoryNestedInput = {
    create?: XOR<UserProfileCreateWithoutSessionHistoryInput, UserProfileUncheckedCreateWithoutSessionHistoryInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutSessionHistoryInput
    upsert?: UserProfileUpsertWithoutSessionHistoryInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutSessionHistoryInput, UserProfileUpdateWithoutSessionHistoryInput>, UserProfileUncheckedUpdateWithoutSessionHistoryInput>
  }

  export type GameUpdateOneRequiredWithoutSessionHistoryNestedInput = {
    create?: XOR<GameCreateWithoutSessionHistoryInput, GameUncheckedCreateWithoutSessionHistoryInput>
    connectOrCreate?: GameCreateOrConnectWithoutSessionHistoryInput
    upsert?: GameUpsertWithoutSessionHistoryInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutSessionHistoryInput, GameUpdateWithoutSessionHistoryInput>, GameUncheckedUpdateWithoutSessionHistoryInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type NestedEnumSessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypeFilter<$PrismaModel> | $Enums.SessionType
  }

  export type NestedEnumVideoQualityFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoQuality | EnumVideoQualityFieldRefInput<$PrismaModel>
    in?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoQualityFilter<$PrismaModel> | $Enums.VideoQuality
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumSessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionTypeFilter<$PrismaModel>
    _max?: NestedEnumSessionTypeFilter<$PrismaModel>
  }

  export type NestedEnumVideoQualityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoQuality | EnumVideoQualityFieldRefInput<$PrismaModel>
    in?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoQuality[] | ListEnumVideoQualityFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoQualityWithAggregatesFilter<$PrismaModel> | $Enums.VideoQuality
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoQualityFilter<$PrismaModel>
    _max?: NestedEnumVideoQualityFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumParticipantRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantRole | EnumParticipantRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantRole[] | ListEnumParticipantRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantRole[] | ListEnumParticipantRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantRoleFilter<$PrismaModel> | $Enums.ParticipantRole
  }

  export type NestedEnumParticipantRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantRole | EnumParticipantRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantRole[] | ListEnumParticipantRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantRole[] | ListEnumParticipantRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantRoleWithAggregatesFilter<$PrismaModel> | $Enums.ParticipantRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParticipantRoleFilter<$PrismaModel>
    _max?: NestedEnumParticipantRoleFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus
  }

  export type NestedEnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusFilter<$PrismaModel>
    _max?: NestedEnumGameStatusFilter<$PrismaModel>
  }

  export type GameSessionCreateWithoutCreatorInput = {
    id?: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
    game: GameCreateNestedOneWithoutSessionsInput
    participants?: SessionParticipantCreateNestedManyWithoutSessionInput
    chatMessages?: SessionChatCreateNestedManyWithoutSessionInput
    history?: SessionHistoryCreateNestedManyWithoutSessionInput
  }

  export type GameSessionUncheckedCreateWithoutCreatorInput = {
    id?: string
    gameId: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
    participants?: SessionParticipantUncheckedCreateNestedManyWithoutSessionInput
    chatMessages?: SessionChatUncheckedCreateNestedManyWithoutSessionInput
    history?: SessionHistoryUncheckedCreateNestedManyWithoutSessionInput
  }

  export type GameSessionCreateOrConnectWithoutCreatorInput = {
    where: GameSessionWhereUniqueInput
    create: XOR<GameSessionCreateWithoutCreatorInput, GameSessionUncheckedCreateWithoutCreatorInput>
  }

  export type GameSessionCreateManyCreatorInputEnvelope = {
    data: GameSessionCreateManyCreatorInput | GameSessionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type UserGameLibraryCreateWithoutUserInput = {
    status?: $Enums.GameStatus
    playTimeMinutes?: number
    lastPlayedAt?: Date | string | null
    rating?: number | null
    addedAt?: Date | string
    game: GameCreateNestedOneWithoutLibraryEntriesInput
  }

  export type UserGameLibraryUncheckedCreateWithoutUserInput = {
    gameId: string
    status?: $Enums.GameStatus
    playTimeMinutes?: number
    lastPlayedAt?: Date | string | null
    rating?: number | null
    addedAt?: Date | string
  }

  export type UserGameLibraryCreateOrConnectWithoutUserInput = {
    where: UserGameLibraryWhereUniqueInput
    create: XOR<UserGameLibraryCreateWithoutUserInput, UserGameLibraryUncheckedCreateWithoutUserInput>
  }

  export type UserGameLibraryCreateManyUserInputEnvelope = {
    data: UserGameLibraryCreateManyUserInput | UserGameLibraryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionParticipantCreateWithoutUserInput = {
    role?: $Enums.ParticipantRole
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    totalDurationMinutes?: number
    session: GameSessionCreateNestedOneWithoutParticipantsInput
  }

  export type SessionParticipantUncheckedCreateWithoutUserInput = {
    sessionId: string
    role?: $Enums.ParticipantRole
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    totalDurationMinutes?: number
  }

  export type SessionParticipantCreateOrConnectWithoutUserInput = {
    where: SessionParticipantWhereUniqueInput
    create: XOR<SessionParticipantCreateWithoutUserInput, SessionParticipantUncheckedCreateWithoutUserInput>
  }

  export type SessionParticipantCreateManyUserInputEnvelope = {
    data: SessionParticipantCreateManyUserInput | SessionParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionChatCreateWithoutUserInput = {
    id?: string
    message: string
    type?: $Enums.MessageType
    createdAt?: Date | string
    session: GameSessionCreateNestedOneWithoutChatMessagesInput
  }

  export type SessionChatUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    message: string
    type?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type SessionChatCreateOrConnectWithoutUserInput = {
    where: SessionChatWhereUniqueInput
    create: XOR<SessionChatCreateWithoutUserInput, SessionChatUncheckedCreateWithoutUserInput>
  }

  export type SessionChatCreateManyUserInputEnvelope = {
    data: SessionChatCreateManyUserInput | SessionChatCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionHistoryCreateWithoutUserInput = {
    id?: string
    role: $Enums.ParticipantRole
    startedAt: Date | string
    endedAt: Date | string
    durationMinutes: number
    totalPlayers?: number
    session: GameSessionCreateNestedOneWithoutHistoryInput
    game: GameCreateNestedOneWithoutSessionHistoryInput
  }

  export type SessionHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    gameId: string
    role: $Enums.ParticipantRole
    startedAt: Date | string
    endedAt: Date | string
    durationMinutes: number
    totalPlayers?: number
  }

  export type SessionHistoryCreateOrConnectWithoutUserInput = {
    where: SessionHistoryWhereUniqueInput
    create: XOR<SessionHistoryCreateWithoutUserInput, SessionHistoryUncheckedCreateWithoutUserInput>
  }

  export type SessionHistoryCreateManyUserInputEnvelope = {
    data: SessionHistoryCreateManyUserInput | SessionHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GameSessionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: GameSessionWhereUniqueInput
    update: XOR<GameSessionUpdateWithoutCreatorInput, GameSessionUncheckedUpdateWithoutCreatorInput>
    create: XOR<GameSessionCreateWithoutCreatorInput, GameSessionUncheckedCreateWithoutCreatorInput>
  }

  export type GameSessionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: GameSessionWhereUniqueInput
    data: XOR<GameSessionUpdateWithoutCreatorInput, GameSessionUncheckedUpdateWithoutCreatorInput>
  }

  export type GameSessionUpdateManyWithWhereWithoutCreatorInput = {
    where: GameSessionScalarWhereInput
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type GameSessionScalarWhereInput = {
    AND?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
    OR?: GameSessionScalarWhereInput[]
    NOT?: GameSessionScalarWhereInput | GameSessionScalarWhereInput[]
    id?: StringFilter<"GameSession"> | string
    gameId?: StringFilter<"GameSession"> | string
    createdBy?: StringFilter<"GameSession"> | string
    sessionCode?: StringNullableFilter<"GameSession"> | string | null
    status?: EnumSessionStatusFilter<"GameSession"> | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFilter<"GameSession"> | $Enums.SessionType
    isPrivate?: BoolFilter<"GameSession"> | boolean
    maxPlayers?: IntFilter<"GameSession"> | number
    currentPlayers?: IntFilter<"GameSession"> | number
    spectatorCount?: IntFilter<"GameSession"> | number
    containerId?: StringNullableFilter<"GameSession"> | string | null
    containerIp?: StringNullableFilter<"GameSession"> | string | null
    containerPort?: IntNullableFilter<"GameSession"> | number | null
    videoQuality?: EnumVideoQualityFilter<"GameSession"> | $Enums.VideoQuality
    fps?: IntFilter<"GameSession"> | number
    startedAt?: DateTimeFilter<"GameSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"GameSession"> | Date | string | null
    lastActivityAt?: DateTimeFilter<"GameSession"> | Date | string
    durationMinutes?: IntNullableFilter<"GameSession"> | number | null
  }

  export type UserGameLibraryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserGameLibraryWhereUniqueInput
    update: XOR<UserGameLibraryUpdateWithoutUserInput, UserGameLibraryUncheckedUpdateWithoutUserInput>
    create: XOR<UserGameLibraryCreateWithoutUserInput, UserGameLibraryUncheckedCreateWithoutUserInput>
  }

  export type UserGameLibraryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserGameLibraryWhereUniqueInput
    data: XOR<UserGameLibraryUpdateWithoutUserInput, UserGameLibraryUncheckedUpdateWithoutUserInput>
  }

  export type UserGameLibraryUpdateManyWithWhereWithoutUserInput = {
    where: UserGameLibraryScalarWhereInput
    data: XOR<UserGameLibraryUpdateManyMutationInput, UserGameLibraryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserGameLibraryScalarWhereInput = {
    AND?: UserGameLibraryScalarWhereInput | UserGameLibraryScalarWhereInput[]
    OR?: UserGameLibraryScalarWhereInput[]
    NOT?: UserGameLibraryScalarWhereInput | UserGameLibraryScalarWhereInput[]
    userId?: StringFilter<"UserGameLibrary"> | string
    gameId?: StringFilter<"UserGameLibrary"> | string
    status?: EnumGameStatusFilter<"UserGameLibrary"> | $Enums.GameStatus
    playTimeMinutes?: IntFilter<"UserGameLibrary"> | number
    lastPlayedAt?: DateTimeNullableFilter<"UserGameLibrary"> | Date | string | null
    rating?: IntNullableFilter<"UserGameLibrary"> | number | null
    addedAt?: DateTimeFilter<"UserGameLibrary"> | Date | string
  }

  export type SessionParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionParticipantWhereUniqueInput
    update: XOR<SessionParticipantUpdateWithoutUserInput, SessionParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<SessionParticipantCreateWithoutUserInput, SessionParticipantUncheckedCreateWithoutUserInput>
  }

  export type SessionParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionParticipantWhereUniqueInput
    data: XOR<SessionParticipantUpdateWithoutUserInput, SessionParticipantUncheckedUpdateWithoutUserInput>
  }

  export type SessionParticipantUpdateManyWithWhereWithoutUserInput = {
    where: SessionParticipantScalarWhereInput
    data: XOR<SessionParticipantUpdateManyMutationInput, SessionParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionParticipantScalarWhereInput = {
    AND?: SessionParticipantScalarWhereInput | SessionParticipantScalarWhereInput[]
    OR?: SessionParticipantScalarWhereInput[]
    NOT?: SessionParticipantScalarWhereInput | SessionParticipantScalarWhereInput[]
    sessionId?: StringFilter<"SessionParticipant"> | string
    userId?: StringFilter<"SessionParticipant"> | string
    role?: EnumParticipantRoleFilter<"SessionParticipant"> | $Enums.ParticipantRole
    isHost?: BoolFilter<"SessionParticipant"> | boolean
    joinedAt?: DateTimeFilter<"SessionParticipant"> | Date | string
    leftAt?: DateTimeNullableFilter<"SessionParticipant"> | Date | string | null
    totalDurationMinutes?: IntFilter<"SessionParticipant"> | number
  }

  export type SessionChatUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionChatWhereUniqueInput
    update: XOR<SessionChatUpdateWithoutUserInput, SessionChatUncheckedUpdateWithoutUserInput>
    create: XOR<SessionChatCreateWithoutUserInput, SessionChatUncheckedCreateWithoutUserInput>
  }

  export type SessionChatUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionChatWhereUniqueInput
    data: XOR<SessionChatUpdateWithoutUserInput, SessionChatUncheckedUpdateWithoutUserInput>
  }

  export type SessionChatUpdateManyWithWhereWithoutUserInput = {
    where: SessionChatScalarWhereInput
    data: XOR<SessionChatUpdateManyMutationInput, SessionChatUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionChatScalarWhereInput = {
    AND?: SessionChatScalarWhereInput | SessionChatScalarWhereInput[]
    OR?: SessionChatScalarWhereInput[]
    NOT?: SessionChatScalarWhereInput | SessionChatScalarWhereInput[]
    id?: StringFilter<"SessionChat"> | string
    sessionId?: StringFilter<"SessionChat"> | string
    userId?: StringFilter<"SessionChat"> | string
    message?: StringFilter<"SessionChat"> | string
    type?: EnumMessageTypeFilter<"SessionChat"> | $Enums.MessageType
    createdAt?: DateTimeFilter<"SessionChat"> | Date | string
  }

  export type SessionHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionHistoryWhereUniqueInput
    update: XOR<SessionHistoryUpdateWithoutUserInput, SessionHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<SessionHistoryCreateWithoutUserInput, SessionHistoryUncheckedCreateWithoutUserInput>
  }

  export type SessionHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionHistoryWhereUniqueInput
    data: XOR<SessionHistoryUpdateWithoutUserInput, SessionHistoryUncheckedUpdateWithoutUserInput>
  }

  export type SessionHistoryUpdateManyWithWhereWithoutUserInput = {
    where: SessionHistoryScalarWhereInput
    data: XOR<SessionHistoryUpdateManyMutationInput, SessionHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionHistoryScalarWhereInput = {
    AND?: SessionHistoryScalarWhereInput | SessionHistoryScalarWhereInput[]
    OR?: SessionHistoryScalarWhereInput[]
    NOT?: SessionHistoryScalarWhereInput | SessionHistoryScalarWhereInput[]
    id?: StringFilter<"SessionHistory"> | string
    sessionId?: StringFilter<"SessionHistory"> | string
    userId?: StringFilter<"SessionHistory"> | string
    gameId?: StringFilter<"SessionHistory"> | string
    role?: EnumParticipantRoleFilter<"SessionHistory"> | $Enums.ParticipantRole
    startedAt?: DateTimeFilter<"SessionHistory"> | Date | string
    endedAt?: DateTimeFilter<"SessionHistory"> | Date | string
    durationMinutes?: IntFilter<"SessionHistory"> | number
    totalPlayers?: IntFilter<"SessionHistory"> | number
  }

  export type GameSessionCreateWithoutGameInput = {
    id?: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
    creator: UserProfileCreateNestedOneWithoutCreatedSessionsInput
    participants?: SessionParticipantCreateNestedManyWithoutSessionInput
    chatMessages?: SessionChatCreateNestedManyWithoutSessionInput
    history?: SessionHistoryCreateNestedManyWithoutSessionInput
  }

  export type GameSessionUncheckedCreateWithoutGameInput = {
    id?: string
    createdBy: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
    participants?: SessionParticipantUncheckedCreateNestedManyWithoutSessionInput
    chatMessages?: SessionChatUncheckedCreateNestedManyWithoutSessionInput
    history?: SessionHistoryUncheckedCreateNestedManyWithoutSessionInput
  }

  export type GameSessionCreateOrConnectWithoutGameInput = {
    where: GameSessionWhereUniqueInput
    create: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput>
  }

  export type GameSessionCreateManyGameInputEnvelope = {
    data: GameSessionCreateManyGameInput | GameSessionCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type UserGameLibraryCreateWithoutGameInput = {
    status?: $Enums.GameStatus
    playTimeMinutes?: number
    lastPlayedAt?: Date | string | null
    rating?: number | null
    addedAt?: Date | string
    user: UserProfileCreateNestedOneWithoutLibraryInput
  }

  export type UserGameLibraryUncheckedCreateWithoutGameInput = {
    userId: string
    status?: $Enums.GameStatus
    playTimeMinutes?: number
    lastPlayedAt?: Date | string | null
    rating?: number | null
    addedAt?: Date | string
  }

  export type UserGameLibraryCreateOrConnectWithoutGameInput = {
    where: UserGameLibraryWhereUniqueInput
    create: XOR<UserGameLibraryCreateWithoutGameInput, UserGameLibraryUncheckedCreateWithoutGameInput>
  }

  export type UserGameLibraryCreateManyGameInputEnvelope = {
    data: UserGameLibraryCreateManyGameInput | UserGameLibraryCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type SessionHistoryCreateWithoutGameInput = {
    id?: string
    role: $Enums.ParticipantRole
    startedAt: Date | string
    endedAt: Date | string
    durationMinutes: number
    totalPlayers?: number
    session: GameSessionCreateNestedOneWithoutHistoryInput
    user: UserProfileCreateNestedOneWithoutSessionHistoryInput
  }

  export type SessionHistoryUncheckedCreateWithoutGameInput = {
    id?: string
    sessionId: string
    userId: string
    role: $Enums.ParticipantRole
    startedAt: Date | string
    endedAt: Date | string
    durationMinutes: number
    totalPlayers?: number
  }

  export type SessionHistoryCreateOrConnectWithoutGameInput = {
    where: SessionHistoryWhereUniqueInput
    create: XOR<SessionHistoryCreateWithoutGameInput, SessionHistoryUncheckedCreateWithoutGameInput>
  }

  export type SessionHistoryCreateManyGameInputEnvelope = {
    data: SessionHistoryCreateManyGameInput | SessionHistoryCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type GameSessionUpsertWithWhereUniqueWithoutGameInput = {
    where: GameSessionWhereUniqueInput
    update: XOR<GameSessionUpdateWithoutGameInput, GameSessionUncheckedUpdateWithoutGameInput>
    create: XOR<GameSessionCreateWithoutGameInput, GameSessionUncheckedCreateWithoutGameInput>
  }

  export type GameSessionUpdateWithWhereUniqueWithoutGameInput = {
    where: GameSessionWhereUniqueInput
    data: XOR<GameSessionUpdateWithoutGameInput, GameSessionUncheckedUpdateWithoutGameInput>
  }

  export type GameSessionUpdateManyWithWhereWithoutGameInput = {
    where: GameSessionScalarWhereInput
    data: XOR<GameSessionUpdateManyMutationInput, GameSessionUncheckedUpdateManyWithoutGameInput>
  }

  export type UserGameLibraryUpsertWithWhereUniqueWithoutGameInput = {
    where: UserGameLibraryWhereUniqueInput
    update: XOR<UserGameLibraryUpdateWithoutGameInput, UserGameLibraryUncheckedUpdateWithoutGameInput>
    create: XOR<UserGameLibraryCreateWithoutGameInput, UserGameLibraryUncheckedCreateWithoutGameInput>
  }

  export type UserGameLibraryUpdateWithWhereUniqueWithoutGameInput = {
    where: UserGameLibraryWhereUniqueInput
    data: XOR<UserGameLibraryUpdateWithoutGameInput, UserGameLibraryUncheckedUpdateWithoutGameInput>
  }

  export type UserGameLibraryUpdateManyWithWhereWithoutGameInput = {
    where: UserGameLibraryScalarWhereInput
    data: XOR<UserGameLibraryUpdateManyMutationInput, UserGameLibraryUncheckedUpdateManyWithoutGameInput>
  }

  export type SessionHistoryUpsertWithWhereUniqueWithoutGameInput = {
    where: SessionHistoryWhereUniqueInput
    update: XOR<SessionHistoryUpdateWithoutGameInput, SessionHistoryUncheckedUpdateWithoutGameInput>
    create: XOR<SessionHistoryCreateWithoutGameInput, SessionHistoryUncheckedCreateWithoutGameInput>
  }

  export type SessionHistoryUpdateWithWhereUniqueWithoutGameInput = {
    where: SessionHistoryWhereUniqueInput
    data: XOR<SessionHistoryUpdateWithoutGameInput, SessionHistoryUncheckedUpdateWithoutGameInput>
  }

  export type SessionHistoryUpdateManyWithWhereWithoutGameInput = {
    where: SessionHistoryScalarWhereInput
    data: XOR<SessionHistoryUpdateManyMutationInput, SessionHistoryUncheckedUpdateManyWithoutGameInput>
  }

  export type GameCreateWithoutSessionsInput = {
    id?: string
    title: string
    slug: string
    system: string
    year?: number | null
    genre?: string | null
    playerCount?: number
    romPath?: string | null
    emulator?: string
    emulatorCore?: string | null
    coverArtUrl?: string | null
    screenshotUrls?: GameCreatescreenshotUrlsInput | string[]
    description?: string | null
    rating?: Decimal | DecimalJsLike | number | string | null
    playCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryEntries?: UserGameLibraryCreateNestedManyWithoutGameInput
    sessionHistory?: SessionHistoryCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutSessionsInput = {
    id?: string
    title: string
    slug: string
    system: string
    year?: number | null
    genre?: string | null
    playerCount?: number
    romPath?: string | null
    emulator?: string
    emulatorCore?: string | null
    coverArtUrl?: string | null
    screenshotUrls?: GameCreatescreenshotUrlsInput | string[]
    description?: string | null
    rating?: Decimal | DecimalJsLike | number | string | null
    playCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    libraryEntries?: UserGameLibraryUncheckedCreateNestedManyWithoutGameInput
    sessionHistory?: SessionHistoryUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutSessionsInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutSessionsInput, GameUncheckedCreateWithoutSessionsInput>
  }

  export type UserProfileCreateWithoutCreatedSessionsInput = {
    id?: string
    platiumUserId: string
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    preferredEmulator?: string | null
    isOnline?: boolean
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    library?: UserGameLibraryCreateNestedManyWithoutUserInput
    participations?: SessionParticipantCreateNestedManyWithoutUserInput
    chatMessages?: SessionChatCreateNestedManyWithoutUserInput
    sessionHistory?: SessionHistoryCreateNestedManyWithoutUserInput
  }

  export type UserProfileUncheckedCreateWithoutCreatedSessionsInput = {
    id?: string
    platiumUserId: string
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    preferredEmulator?: string | null
    isOnline?: boolean
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    library?: UserGameLibraryUncheckedCreateNestedManyWithoutUserInput
    participations?: SessionParticipantUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: SessionChatUncheckedCreateNestedManyWithoutUserInput
    sessionHistory?: SessionHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserProfileCreateOrConnectWithoutCreatedSessionsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutCreatedSessionsInput, UserProfileUncheckedCreateWithoutCreatedSessionsInput>
  }

  export type SessionParticipantCreateWithoutSessionInput = {
    role?: $Enums.ParticipantRole
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    totalDurationMinutes?: number
    user: UserProfileCreateNestedOneWithoutParticipationsInput
  }

  export type SessionParticipantUncheckedCreateWithoutSessionInput = {
    userId: string
    role?: $Enums.ParticipantRole
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    totalDurationMinutes?: number
  }

  export type SessionParticipantCreateOrConnectWithoutSessionInput = {
    where: SessionParticipantWhereUniqueInput
    create: XOR<SessionParticipantCreateWithoutSessionInput, SessionParticipantUncheckedCreateWithoutSessionInput>
  }

  export type SessionParticipantCreateManySessionInputEnvelope = {
    data: SessionParticipantCreateManySessionInput | SessionParticipantCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SessionChatCreateWithoutSessionInput = {
    id?: string
    message: string
    type?: $Enums.MessageType
    createdAt?: Date | string
    user: UserProfileCreateNestedOneWithoutChatMessagesInput
  }

  export type SessionChatUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    message: string
    type?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type SessionChatCreateOrConnectWithoutSessionInput = {
    where: SessionChatWhereUniqueInput
    create: XOR<SessionChatCreateWithoutSessionInput, SessionChatUncheckedCreateWithoutSessionInput>
  }

  export type SessionChatCreateManySessionInputEnvelope = {
    data: SessionChatCreateManySessionInput | SessionChatCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SessionHistoryCreateWithoutSessionInput = {
    id?: string
    role: $Enums.ParticipantRole
    startedAt: Date | string
    endedAt: Date | string
    durationMinutes: number
    totalPlayers?: number
    user: UserProfileCreateNestedOneWithoutSessionHistoryInput
    game: GameCreateNestedOneWithoutSessionHistoryInput
  }

  export type SessionHistoryUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    gameId: string
    role: $Enums.ParticipantRole
    startedAt: Date | string
    endedAt: Date | string
    durationMinutes: number
    totalPlayers?: number
  }

  export type SessionHistoryCreateOrConnectWithoutSessionInput = {
    where: SessionHistoryWhereUniqueInput
    create: XOR<SessionHistoryCreateWithoutSessionInput, SessionHistoryUncheckedCreateWithoutSessionInput>
  }

  export type SessionHistoryCreateManySessionInputEnvelope = {
    data: SessionHistoryCreateManySessionInput | SessionHistoryCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type GameUpsertWithoutSessionsInput = {
    update: XOR<GameUpdateWithoutSessionsInput, GameUncheckedUpdateWithoutSessionsInput>
    create: XOR<GameCreateWithoutSessionsInput, GameUncheckedCreateWithoutSessionsInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutSessionsInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutSessionsInput, GameUncheckedUpdateWithoutSessionsInput>
  }

  export type GameUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    playerCount?: IntFieldUpdateOperationsInput | number
    romPath?: NullableStringFieldUpdateOperationsInput | string | null
    emulator?: StringFieldUpdateOperationsInput | string
    emulatorCore?: NullableStringFieldUpdateOperationsInput | string | null
    coverArtUrl?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotUrls?: GameUpdatescreenshotUrlsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    playCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryEntries?: UserGameLibraryUpdateManyWithoutGameNestedInput
    sessionHistory?: SessionHistoryUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    playerCount?: IntFieldUpdateOperationsInput | number
    romPath?: NullableStringFieldUpdateOperationsInput | string | null
    emulator?: StringFieldUpdateOperationsInput | string
    emulatorCore?: NullableStringFieldUpdateOperationsInput | string | null
    coverArtUrl?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotUrls?: GameUpdatescreenshotUrlsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    playCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryEntries?: UserGameLibraryUncheckedUpdateManyWithoutGameNestedInput
    sessionHistory?: SessionHistoryUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserProfileUpsertWithoutCreatedSessionsInput = {
    update: XOR<UserProfileUpdateWithoutCreatedSessionsInput, UserProfileUncheckedUpdateWithoutCreatedSessionsInput>
    create: XOR<UserProfileCreateWithoutCreatedSessionsInput, UserProfileUncheckedCreateWithoutCreatedSessionsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutCreatedSessionsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutCreatedSessionsInput, UserProfileUncheckedUpdateWithoutCreatedSessionsInput>
  }

  export type UserProfileUpdateWithoutCreatedSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    library?: UserGameLibraryUpdateManyWithoutUserNestedInput
    participations?: SessionParticipantUpdateManyWithoutUserNestedInput
    chatMessages?: SessionChatUpdateManyWithoutUserNestedInput
    sessionHistory?: SessionHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutCreatedSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    library?: UserGameLibraryUncheckedUpdateManyWithoutUserNestedInput
    participations?: SessionParticipantUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: SessionChatUncheckedUpdateManyWithoutUserNestedInput
    sessionHistory?: SessionHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionParticipantUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionParticipantWhereUniqueInput
    update: XOR<SessionParticipantUpdateWithoutSessionInput, SessionParticipantUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionParticipantCreateWithoutSessionInput, SessionParticipantUncheckedCreateWithoutSessionInput>
  }

  export type SessionParticipantUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionParticipantWhereUniqueInput
    data: XOR<SessionParticipantUpdateWithoutSessionInput, SessionParticipantUncheckedUpdateWithoutSessionInput>
  }

  export type SessionParticipantUpdateManyWithWhereWithoutSessionInput = {
    where: SessionParticipantScalarWhereInput
    data: XOR<SessionParticipantUpdateManyMutationInput, SessionParticipantUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionChatUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionChatWhereUniqueInput
    update: XOR<SessionChatUpdateWithoutSessionInput, SessionChatUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionChatCreateWithoutSessionInput, SessionChatUncheckedCreateWithoutSessionInput>
  }

  export type SessionChatUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionChatWhereUniqueInput
    data: XOR<SessionChatUpdateWithoutSessionInput, SessionChatUncheckedUpdateWithoutSessionInput>
  }

  export type SessionChatUpdateManyWithWhereWithoutSessionInput = {
    where: SessionChatScalarWhereInput
    data: XOR<SessionChatUpdateManyMutationInput, SessionChatUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionHistoryUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionHistoryWhereUniqueInput
    update: XOR<SessionHistoryUpdateWithoutSessionInput, SessionHistoryUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionHistoryCreateWithoutSessionInput, SessionHistoryUncheckedCreateWithoutSessionInput>
  }

  export type SessionHistoryUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionHistoryWhereUniqueInput
    data: XOR<SessionHistoryUpdateWithoutSessionInput, SessionHistoryUncheckedUpdateWithoutSessionInput>
  }

  export type SessionHistoryUpdateManyWithWhereWithoutSessionInput = {
    where: SessionHistoryScalarWhereInput
    data: XOR<SessionHistoryUpdateManyMutationInput, SessionHistoryUncheckedUpdateManyWithoutSessionInput>
  }

  export type GameSessionCreateWithoutParticipantsInput = {
    id?: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
    game: GameCreateNestedOneWithoutSessionsInput
    creator: UserProfileCreateNestedOneWithoutCreatedSessionsInput
    chatMessages?: SessionChatCreateNestedManyWithoutSessionInput
    history?: SessionHistoryCreateNestedManyWithoutSessionInput
  }

  export type GameSessionUncheckedCreateWithoutParticipantsInput = {
    id?: string
    gameId: string
    createdBy: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
    chatMessages?: SessionChatUncheckedCreateNestedManyWithoutSessionInput
    history?: SessionHistoryUncheckedCreateNestedManyWithoutSessionInput
  }

  export type GameSessionCreateOrConnectWithoutParticipantsInput = {
    where: GameSessionWhereUniqueInput
    create: XOR<GameSessionCreateWithoutParticipantsInput, GameSessionUncheckedCreateWithoutParticipantsInput>
  }

  export type UserProfileCreateWithoutParticipationsInput = {
    id?: string
    platiumUserId: string
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    preferredEmulator?: string | null
    isOnline?: boolean
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSessions?: GameSessionCreateNestedManyWithoutCreatorInput
    library?: UserGameLibraryCreateNestedManyWithoutUserInput
    chatMessages?: SessionChatCreateNestedManyWithoutUserInput
    sessionHistory?: SessionHistoryCreateNestedManyWithoutUserInput
  }

  export type UserProfileUncheckedCreateWithoutParticipationsInput = {
    id?: string
    platiumUserId: string
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    preferredEmulator?: string | null
    isOnline?: boolean
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSessions?: GameSessionUncheckedCreateNestedManyWithoutCreatorInput
    library?: UserGameLibraryUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: SessionChatUncheckedCreateNestedManyWithoutUserInput
    sessionHistory?: SessionHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserProfileCreateOrConnectWithoutParticipationsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutParticipationsInput, UserProfileUncheckedCreateWithoutParticipationsInput>
  }

  export type GameSessionUpsertWithoutParticipantsInput = {
    update: XOR<GameSessionUpdateWithoutParticipantsInput, GameSessionUncheckedUpdateWithoutParticipantsInput>
    create: XOR<GameSessionCreateWithoutParticipantsInput, GameSessionUncheckedCreateWithoutParticipantsInput>
    where?: GameSessionWhereInput
  }

  export type GameSessionUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: GameSessionWhereInput
    data: XOR<GameSessionUpdateWithoutParticipantsInput, GameSessionUncheckedUpdateWithoutParticipantsInput>
  }

  export type GameSessionUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    game?: GameUpdateOneRequiredWithoutSessionsNestedInput
    creator?: UserProfileUpdateOneRequiredWithoutCreatedSessionsNestedInput
    chatMessages?: SessionChatUpdateManyWithoutSessionNestedInput
    history?: SessionHistoryUpdateManyWithoutSessionNestedInput
  }

  export type GameSessionUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    chatMessages?: SessionChatUncheckedUpdateManyWithoutSessionNestedInput
    history?: SessionHistoryUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserProfileUpsertWithoutParticipationsInput = {
    update: XOR<UserProfileUpdateWithoutParticipationsInput, UserProfileUncheckedUpdateWithoutParticipationsInput>
    create: XOR<UserProfileCreateWithoutParticipationsInput, UserProfileUncheckedCreateWithoutParticipationsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutParticipationsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutParticipationsInput, UserProfileUncheckedUpdateWithoutParticipationsInput>
  }

  export type UserProfileUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSessions?: GameSessionUpdateManyWithoutCreatorNestedInput
    library?: UserGameLibraryUpdateManyWithoutUserNestedInput
    chatMessages?: SessionChatUpdateManyWithoutUserNestedInput
    sessionHistory?: SessionHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSessions?: GameSessionUncheckedUpdateManyWithoutCreatorNestedInput
    library?: UserGameLibraryUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: SessionChatUncheckedUpdateManyWithoutUserNestedInput
    sessionHistory?: SessionHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GameSessionCreateWithoutChatMessagesInput = {
    id?: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
    game: GameCreateNestedOneWithoutSessionsInput
    creator: UserProfileCreateNestedOneWithoutCreatedSessionsInput
    participants?: SessionParticipantCreateNestedManyWithoutSessionInput
    history?: SessionHistoryCreateNestedManyWithoutSessionInput
  }

  export type GameSessionUncheckedCreateWithoutChatMessagesInput = {
    id?: string
    gameId: string
    createdBy: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
    participants?: SessionParticipantUncheckedCreateNestedManyWithoutSessionInput
    history?: SessionHistoryUncheckedCreateNestedManyWithoutSessionInput
  }

  export type GameSessionCreateOrConnectWithoutChatMessagesInput = {
    where: GameSessionWhereUniqueInput
    create: XOR<GameSessionCreateWithoutChatMessagesInput, GameSessionUncheckedCreateWithoutChatMessagesInput>
  }

  export type UserProfileCreateWithoutChatMessagesInput = {
    id?: string
    platiumUserId: string
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    preferredEmulator?: string | null
    isOnline?: boolean
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSessions?: GameSessionCreateNestedManyWithoutCreatorInput
    library?: UserGameLibraryCreateNestedManyWithoutUserInput
    participations?: SessionParticipantCreateNestedManyWithoutUserInput
    sessionHistory?: SessionHistoryCreateNestedManyWithoutUserInput
  }

  export type UserProfileUncheckedCreateWithoutChatMessagesInput = {
    id?: string
    platiumUserId: string
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    preferredEmulator?: string | null
    isOnline?: boolean
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSessions?: GameSessionUncheckedCreateNestedManyWithoutCreatorInput
    library?: UserGameLibraryUncheckedCreateNestedManyWithoutUserInput
    participations?: SessionParticipantUncheckedCreateNestedManyWithoutUserInput
    sessionHistory?: SessionHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserProfileCreateOrConnectWithoutChatMessagesInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutChatMessagesInput, UserProfileUncheckedCreateWithoutChatMessagesInput>
  }

  export type GameSessionUpsertWithoutChatMessagesInput = {
    update: XOR<GameSessionUpdateWithoutChatMessagesInput, GameSessionUncheckedUpdateWithoutChatMessagesInput>
    create: XOR<GameSessionCreateWithoutChatMessagesInput, GameSessionUncheckedCreateWithoutChatMessagesInput>
    where?: GameSessionWhereInput
  }

  export type GameSessionUpdateToOneWithWhereWithoutChatMessagesInput = {
    where?: GameSessionWhereInput
    data: XOR<GameSessionUpdateWithoutChatMessagesInput, GameSessionUncheckedUpdateWithoutChatMessagesInput>
  }

  export type GameSessionUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    game?: GameUpdateOneRequiredWithoutSessionsNestedInput
    creator?: UserProfileUpdateOneRequiredWithoutCreatedSessionsNestedInput
    participants?: SessionParticipantUpdateManyWithoutSessionNestedInput
    history?: SessionHistoryUpdateManyWithoutSessionNestedInput
  }

  export type GameSessionUncheckedUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    participants?: SessionParticipantUncheckedUpdateManyWithoutSessionNestedInput
    history?: SessionHistoryUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserProfileUpsertWithoutChatMessagesInput = {
    update: XOR<UserProfileUpdateWithoutChatMessagesInput, UserProfileUncheckedUpdateWithoutChatMessagesInput>
    create: XOR<UserProfileCreateWithoutChatMessagesInput, UserProfileUncheckedCreateWithoutChatMessagesInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutChatMessagesInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutChatMessagesInput, UserProfileUncheckedUpdateWithoutChatMessagesInput>
  }

  export type UserProfileUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSessions?: GameSessionUpdateManyWithoutCreatorNestedInput
    library?: UserGameLibraryUpdateManyWithoutUserNestedInput
    participations?: SessionParticipantUpdateManyWithoutUserNestedInput
    sessionHistory?: SessionHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSessions?: GameSessionUncheckedUpdateManyWithoutCreatorNestedInput
    library?: UserGameLibraryUncheckedUpdateManyWithoutUserNestedInput
    participations?: SessionParticipantUncheckedUpdateManyWithoutUserNestedInput
    sessionHistory?: SessionHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserProfileCreateWithoutLibraryInput = {
    id?: string
    platiumUserId: string
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    preferredEmulator?: string | null
    isOnline?: boolean
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSessions?: GameSessionCreateNestedManyWithoutCreatorInput
    participations?: SessionParticipantCreateNestedManyWithoutUserInput
    chatMessages?: SessionChatCreateNestedManyWithoutUserInput
    sessionHistory?: SessionHistoryCreateNestedManyWithoutUserInput
  }

  export type UserProfileUncheckedCreateWithoutLibraryInput = {
    id?: string
    platiumUserId: string
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    preferredEmulator?: string | null
    isOnline?: boolean
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSessions?: GameSessionUncheckedCreateNestedManyWithoutCreatorInput
    participations?: SessionParticipantUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: SessionChatUncheckedCreateNestedManyWithoutUserInput
    sessionHistory?: SessionHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserProfileCreateOrConnectWithoutLibraryInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutLibraryInput, UserProfileUncheckedCreateWithoutLibraryInput>
  }

  export type GameCreateWithoutLibraryEntriesInput = {
    id?: string
    title: string
    slug: string
    system: string
    year?: number | null
    genre?: string | null
    playerCount?: number
    romPath?: string | null
    emulator?: string
    emulatorCore?: string | null
    coverArtUrl?: string | null
    screenshotUrls?: GameCreatescreenshotUrlsInput | string[]
    description?: string | null
    rating?: Decimal | DecimalJsLike | number | string | null
    playCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    sessionHistory?: SessionHistoryCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutLibraryEntriesInput = {
    id?: string
    title: string
    slug: string
    system: string
    year?: number | null
    genre?: string | null
    playerCount?: number
    romPath?: string | null
    emulator?: string
    emulatorCore?: string | null
    coverArtUrl?: string | null
    screenshotUrls?: GameCreatescreenshotUrlsInput | string[]
    description?: string | null
    rating?: Decimal | DecimalJsLike | number | string | null
    playCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    sessionHistory?: SessionHistoryUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutLibraryEntriesInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutLibraryEntriesInput, GameUncheckedCreateWithoutLibraryEntriesInput>
  }

  export type UserProfileUpsertWithoutLibraryInput = {
    update: XOR<UserProfileUpdateWithoutLibraryInput, UserProfileUncheckedUpdateWithoutLibraryInput>
    create: XOR<UserProfileCreateWithoutLibraryInput, UserProfileUncheckedCreateWithoutLibraryInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutLibraryInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutLibraryInput, UserProfileUncheckedUpdateWithoutLibraryInput>
  }

  export type UserProfileUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSessions?: GameSessionUpdateManyWithoutCreatorNestedInput
    participations?: SessionParticipantUpdateManyWithoutUserNestedInput
    chatMessages?: SessionChatUpdateManyWithoutUserNestedInput
    sessionHistory?: SessionHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSessions?: GameSessionUncheckedUpdateManyWithoutCreatorNestedInput
    participations?: SessionParticipantUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: SessionChatUncheckedUpdateManyWithoutUserNestedInput
    sessionHistory?: SessionHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GameUpsertWithoutLibraryEntriesInput = {
    update: XOR<GameUpdateWithoutLibraryEntriesInput, GameUncheckedUpdateWithoutLibraryEntriesInput>
    create: XOR<GameCreateWithoutLibraryEntriesInput, GameUncheckedCreateWithoutLibraryEntriesInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutLibraryEntriesInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutLibraryEntriesInput, GameUncheckedUpdateWithoutLibraryEntriesInput>
  }

  export type GameUpdateWithoutLibraryEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    playerCount?: IntFieldUpdateOperationsInput | number
    romPath?: NullableStringFieldUpdateOperationsInput | string | null
    emulator?: StringFieldUpdateOperationsInput | string
    emulatorCore?: NullableStringFieldUpdateOperationsInput | string | null
    coverArtUrl?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotUrls?: GameUpdatescreenshotUrlsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    playCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    sessionHistory?: SessionHistoryUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutLibraryEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    playerCount?: IntFieldUpdateOperationsInput | number
    romPath?: NullableStringFieldUpdateOperationsInput | string | null
    emulator?: StringFieldUpdateOperationsInput | string
    emulatorCore?: NullableStringFieldUpdateOperationsInput | string | null
    coverArtUrl?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotUrls?: GameUpdatescreenshotUrlsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    playCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    sessionHistory?: SessionHistoryUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameSessionCreateWithoutHistoryInput = {
    id?: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
    game: GameCreateNestedOneWithoutSessionsInput
    creator: UserProfileCreateNestedOneWithoutCreatedSessionsInput
    participants?: SessionParticipantCreateNestedManyWithoutSessionInput
    chatMessages?: SessionChatCreateNestedManyWithoutSessionInput
  }

  export type GameSessionUncheckedCreateWithoutHistoryInput = {
    id?: string
    gameId: string
    createdBy: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
    participants?: SessionParticipantUncheckedCreateNestedManyWithoutSessionInput
    chatMessages?: SessionChatUncheckedCreateNestedManyWithoutSessionInput
  }

  export type GameSessionCreateOrConnectWithoutHistoryInput = {
    where: GameSessionWhereUniqueInput
    create: XOR<GameSessionCreateWithoutHistoryInput, GameSessionUncheckedCreateWithoutHistoryInput>
  }

  export type UserProfileCreateWithoutSessionHistoryInput = {
    id?: string
    platiumUserId: string
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    preferredEmulator?: string | null
    isOnline?: boolean
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSessions?: GameSessionCreateNestedManyWithoutCreatorInput
    library?: UserGameLibraryCreateNestedManyWithoutUserInput
    participations?: SessionParticipantCreateNestedManyWithoutUserInput
    chatMessages?: SessionChatCreateNestedManyWithoutUserInput
  }

  export type UserProfileUncheckedCreateWithoutSessionHistoryInput = {
    id?: string
    platiumUserId: string
    username: string
    displayName?: string | null
    avatarUrl?: string | null
    preferredEmulator?: string | null
    isOnline?: boolean
    lastSeenAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdSessions?: GameSessionUncheckedCreateNestedManyWithoutCreatorInput
    library?: UserGameLibraryUncheckedCreateNestedManyWithoutUserInput
    participations?: SessionParticipantUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: SessionChatUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserProfileCreateOrConnectWithoutSessionHistoryInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutSessionHistoryInput, UserProfileUncheckedCreateWithoutSessionHistoryInput>
  }

  export type GameCreateWithoutSessionHistoryInput = {
    id?: string
    title: string
    slug: string
    system: string
    year?: number | null
    genre?: string | null
    playerCount?: number
    romPath?: string | null
    emulator?: string
    emulatorCore?: string | null
    coverArtUrl?: string | null
    screenshotUrls?: GameCreatescreenshotUrlsInput | string[]
    description?: string | null
    rating?: Decimal | DecimalJsLike | number | string | null
    playCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: GameSessionCreateNestedManyWithoutGameInput
    libraryEntries?: UserGameLibraryCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutSessionHistoryInput = {
    id?: string
    title: string
    slug: string
    system: string
    year?: number | null
    genre?: string | null
    playerCount?: number
    romPath?: string | null
    emulator?: string
    emulatorCore?: string | null
    coverArtUrl?: string | null
    screenshotUrls?: GameCreatescreenshotUrlsInput | string[]
    description?: string | null
    rating?: Decimal | DecimalJsLike | number | string | null
    playCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: GameSessionUncheckedCreateNestedManyWithoutGameInput
    libraryEntries?: UserGameLibraryUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutSessionHistoryInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutSessionHistoryInput, GameUncheckedCreateWithoutSessionHistoryInput>
  }

  export type GameSessionUpsertWithoutHistoryInput = {
    update: XOR<GameSessionUpdateWithoutHistoryInput, GameSessionUncheckedUpdateWithoutHistoryInput>
    create: XOR<GameSessionCreateWithoutHistoryInput, GameSessionUncheckedCreateWithoutHistoryInput>
    where?: GameSessionWhereInput
  }

  export type GameSessionUpdateToOneWithWhereWithoutHistoryInput = {
    where?: GameSessionWhereInput
    data: XOR<GameSessionUpdateWithoutHistoryInput, GameSessionUncheckedUpdateWithoutHistoryInput>
  }

  export type GameSessionUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    game?: GameUpdateOneRequiredWithoutSessionsNestedInput
    creator?: UserProfileUpdateOneRequiredWithoutCreatedSessionsNestedInput
    participants?: SessionParticipantUpdateManyWithoutSessionNestedInput
    chatMessages?: SessionChatUpdateManyWithoutSessionNestedInput
  }

  export type GameSessionUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    participants?: SessionParticipantUncheckedUpdateManyWithoutSessionNestedInput
    chatMessages?: SessionChatUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserProfileUpsertWithoutSessionHistoryInput = {
    update: XOR<UserProfileUpdateWithoutSessionHistoryInput, UserProfileUncheckedUpdateWithoutSessionHistoryInput>
    create: XOR<UserProfileCreateWithoutSessionHistoryInput, UserProfileUncheckedCreateWithoutSessionHistoryInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutSessionHistoryInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutSessionHistoryInput, UserProfileUncheckedUpdateWithoutSessionHistoryInput>
  }

  export type UserProfileUpdateWithoutSessionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSessions?: GameSessionUpdateManyWithoutCreatorNestedInput
    library?: UserGameLibraryUpdateManyWithoutUserNestedInput
    participations?: SessionParticipantUpdateManyWithoutUserNestedInput
    chatMessages?: SessionChatUpdateManyWithoutUserNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutSessionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    platiumUserId?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredEmulator?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdSessions?: GameSessionUncheckedUpdateManyWithoutCreatorNestedInput
    library?: UserGameLibraryUncheckedUpdateManyWithoutUserNestedInput
    participations?: SessionParticipantUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: SessionChatUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GameUpsertWithoutSessionHistoryInput = {
    update: XOR<GameUpdateWithoutSessionHistoryInput, GameUncheckedUpdateWithoutSessionHistoryInput>
    create: XOR<GameCreateWithoutSessionHistoryInput, GameUncheckedCreateWithoutSessionHistoryInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutSessionHistoryInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutSessionHistoryInput, GameUncheckedUpdateWithoutSessionHistoryInput>
  }

  export type GameUpdateWithoutSessionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    playerCount?: IntFieldUpdateOperationsInput | number
    romPath?: NullableStringFieldUpdateOperationsInput | string | null
    emulator?: StringFieldUpdateOperationsInput | string
    emulatorCore?: NullableStringFieldUpdateOperationsInput | string | null
    coverArtUrl?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotUrls?: GameUpdatescreenshotUrlsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    playCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: GameSessionUpdateManyWithoutGameNestedInput
    libraryEntries?: UserGameLibraryUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutSessionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    genre?: NullableStringFieldUpdateOperationsInput | string | null
    playerCount?: IntFieldUpdateOperationsInput | number
    romPath?: NullableStringFieldUpdateOperationsInput | string | null
    emulator?: StringFieldUpdateOperationsInput | string
    emulatorCore?: NullableStringFieldUpdateOperationsInput | string | null
    coverArtUrl?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotUrls?: GameUpdatescreenshotUrlsInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    playCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: GameSessionUncheckedUpdateManyWithoutGameNestedInput
    libraryEntries?: UserGameLibraryUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameSessionCreateManyCreatorInput = {
    id?: string
    gameId: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
  }

  export type UserGameLibraryCreateManyUserInput = {
    gameId: string
    status?: $Enums.GameStatus
    playTimeMinutes?: number
    lastPlayedAt?: Date | string | null
    rating?: number | null
    addedAt?: Date | string
  }

  export type SessionParticipantCreateManyUserInput = {
    sessionId: string
    role?: $Enums.ParticipantRole
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    totalDurationMinutes?: number
  }

  export type SessionChatCreateManyUserInput = {
    id?: string
    sessionId: string
    message: string
    type?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type SessionHistoryCreateManyUserInput = {
    id?: string
    sessionId: string
    gameId: string
    role: $Enums.ParticipantRole
    startedAt: Date | string
    endedAt: Date | string
    durationMinutes: number
    totalPlayers?: number
  }

  export type GameSessionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    game?: GameUpdateOneRequiredWithoutSessionsNestedInput
    participants?: SessionParticipantUpdateManyWithoutSessionNestedInput
    chatMessages?: SessionChatUpdateManyWithoutSessionNestedInput
    history?: SessionHistoryUpdateManyWithoutSessionNestedInput
  }

  export type GameSessionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    participants?: SessionParticipantUncheckedUpdateManyWithoutSessionNestedInput
    chatMessages?: SessionChatUncheckedUpdateManyWithoutSessionNestedInput
    history?: SessionHistoryUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type GameSessionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserGameLibraryUpdateWithoutUserInput = {
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    playTimeMinutes?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    game?: GameUpdateOneRequiredWithoutLibraryEntriesNestedInput
  }

  export type UserGameLibraryUncheckedUpdateWithoutUserInput = {
    gameId?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    playTimeMinutes?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGameLibraryUncheckedUpdateManyWithoutUserInput = {
    gameId?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    playTimeMinutes?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionParticipantUpdateWithoutUserInput = {
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    session?: GameSessionUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type SessionParticipantUncheckedUpdateWithoutUserInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
  }

  export type SessionParticipantUncheckedUpdateManyWithoutUserInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
  }

  export type SessionChatUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: GameSessionUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type SessionChatUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionChatUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    totalPlayers?: IntFieldUpdateOperationsInput | number
    session?: GameSessionUpdateOneRequiredWithoutHistoryNestedInput
    game?: GameUpdateOneRequiredWithoutSessionHistoryNestedInput
  }

  export type SessionHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    totalPlayers?: IntFieldUpdateOperationsInput | number
  }

  export type SessionHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    totalPlayers?: IntFieldUpdateOperationsInput | number
  }

  export type GameSessionCreateManyGameInput = {
    id?: string
    createdBy: string
    sessionCode?: string | null
    status?: $Enums.SessionStatus
    sessionType?: $Enums.SessionType
    isPrivate?: boolean
    maxPlayers?: number
    currentPlayers?: number
    spectatorCount?: number
    containerId?: string | null
    containerIp?: string | null
    containerPort?: number | null
    videoQuality?: $Enums.VideoQuality
    fps?: number
    startedAt?: Date | string
    endedAt?: Date | string | null
    lastActivityAt?: Date | string
    durationMinutes?: number | null
  }

  export type UserGameLibraryCreateManyGameInput = {
    userId: string
    status?: $Enums.GameStatus
    playTimeMinutes?: number
    lastPlayedAt?: Date | string | null
    rating?: number | null
    addedAt?: Date | string
  }

  export type SessionHistoryCreateManyGameInput = {
    id?: string
    sessionId: string
    userId: string
    role: $Enums.ParticipantRole
    startedAt: Date | string
    endedAt: Date | string
    durationMinutes: number
    totalPlayers?: number
  }

  export type GameSessionUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    creator?: UserProfileUpdateOneRequiredWithoutCreatedSessionsNestedInput
    participants?: SessionParticipantUpdateManyWithoutSessionNestedInput
    chatMessages?: SessionChatUpdateManyWithoutSessionNestedInput
    history?: SessionHistoryUpdateManyWithoutSessionNestedInput
  }

  export type GameSessionUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    participants?: SessionParticipantUncheckedUpdateManyWithoutSessionNestedInput
    chatMessages?: SessionChatUncheckedUpdateManyWithoutSessionNestedInput
    history?: SessionHistoryUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type GameSessionUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxPlayers?: IntFieldUpdateOperationsInput | number
    currentPlayers?: IntFieldUpdateOperationsInput | number
    spectatorCount?: IntFieldUpdateOperationsInput | number
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    containerIp?: NullableStringFieldUpdateOperationsInput | string | null
    containerPort?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: EnumVideoQualityFieldUpdateOperationsInput | $Enums.VideoQuality
    fps?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserGameLibraryUpdateWithoutGameInput = {
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    playTimeMinutes?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutLibraryNestedInput
  }

  export type UserGameLibraryUncheckedUpdateWithoutGameInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    playTimeMinutes?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGameLibraryUncheckedUpdateManyWithoutGameInput = {
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    playTimeMinutes?: IntFieldUpdateOperationsInput | number
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionHistoryUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    totalPlayers?: IntFieldUpdateOperationsInput | number
    session?: GameSessionUpdateOneRequiredWithoutHistoryNestedInput
    user?: UserProfileUpdateOneRequiredWithoutSessionHistoryNestedInput
  }

  export type SessionHistoryUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    totalPlayers?: IntFieldUpdateOperationsInput | number
  }

  export type SessionHistoryUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    totalPlayers?: IntFieldUpdateOperationsInput | number
  }

  export type SessionParticipantCreateManySessionInput = {
    userId: string
    role?: $Enums.ParticipantRole
    isHost?: boolean
    joinedAt?: Date | string
    leftAt?: Date | string | null
    totalDurationMinutes?: number
  }

  export type SessionChatCreateManySessionInput = {
    id?: string
    userId: string
    message: string
    type?: $Enums.MessageType
    createdAt?: Date | string
  }

  export type SessionHistoryCreateManySessionInput = {
    id?: string
    userId: string
    gameId: string
    role: $Enums.ParticipantRole
    startedAt: Date | string
    endedAt: Date | string
    durationMinutes: number
    totalPlayers?: number
  }

  export type SessionParticipantUpdateWithoutSessionInput = {
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutParticipationsNestedInput
  }

  export type SessionParticipantUncheckedUpdateWithoutSessionInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
  }

  export type SessionParticipantUncheckedUpdateManyWithoutSessionInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    isHost?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationMinutes?: IntFieldUpdateOperationsInput | number
  }

  export type SessionChatUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserProfileUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type SessionChatUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionChatUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionHistoryUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    totalPlayers?: IntFieldUpdateOperationsInput | number
    user?: UserProfileUpdateOneRequiredWithoutSessionHistoryNestedInput
    game?: GameUpdateOneRequiredWithoutSessionHistoryNestedInput
  }

  export type SessionHistoryUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    totalPlayers?: IntFieldUpdateOperationsInput | number
  }

  export type SessionHistoryUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
    role?: EnumParticipantRoleFieldUpdateOperationsInput | $Enums.ParticipantRole
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    totalPlayers?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserProfileCountOutputTypeDefaultArgs instead
     */
    export type UserProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameCountOutputTypeDefaultArgs instead
     */
    export type GameCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameSessionCountOutputTypeDefaultArgs instead
     */
    export type GameSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserProfileDefaultArgs instead
     */
    export type UserProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameDefaultArgs instead
     */
    export type GameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameSessionDefaultArgs instead
     */
    export type GameSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionParticipantDefaultArgs instead
     */
    export type SessionParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionChatDefaultArgs instead
     */
    export type SessionChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionChatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserGameLibraryDefaultArgs instead
     */
    export type UserGameLibraryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserGameLibraryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionHistoryDefaultArgs instead
     */
    export type SessionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionHistoryDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}